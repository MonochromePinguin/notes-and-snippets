window.addEventListener('load', function() {
	var gridElement = document.getElementsByTagName('main')[0];

	var cellList = gridElement.children,
		nbCells = cellList.length;


	function getColumnCount(cellList) {
		var nbColumns = 0,
			lastY = cellList[0].offsetTop;

		/* THIS IS BASED ON THE ASSUMPTION THAT
					GRID CELLS ARE ALL OF EQUAL WIDTH AND HEIGHT */
		for (let el of cellList) {
		  if (el.offsetTop != lastY) {
			// we just have changed of line, so counting is over
			return nbColumns;
		  }
		  ++nbColumns;
		}

		return nbColumns;
	}


	/* return a newly-created "style" element containing the
	selector for obtaining a cells's background checkerboard pattern
	in a grid of given column count
	*/
	function createCheckerboardCSSforColumns(nbColumns)
	{
		let newCSS = document.createElement('style'),
			text = '',
			cycleLength = 2 * nbColumns;

		const prefix = '.cell:nth-child(',
			  suffix = '{ background-color: var(--cell-color2) }';

		// sufficient for nbColumns == 2
		text += prefix + cycleLength + 'n), ' +
				prefix + cycleLength + 'n+1) ';

		// for nbColumns > 2
		/* algorithm:
						_ for 𝑛 column, the cycle is 2𝑛
						_ and there should be 𝑛/2-1 pairs of:
							:nth-child(2𝑛 +(i*2+1))
							:nth-child(2n-(i*2))
						 for i incrementing from 1 to 𝑛/2-1
					*/
		let iMax = nbColumns/2;
		for ( let i = 1; i < iMax; ++i )
		{
			text += ', ' +
			prefix + cycleLength + 'n+' + ( i*2 +1) + '), ' +
			prefix + cycleLength + 'n-' + (i*2) + ') ';
		}

		newCSS.textContent = text + suffix;
		return newCSS;
	}

	/*add or remove a dynamically generated styleSheet
	 generated by createCSSforColumns(). The generated styleSheets
	 are stored in a cache just in case of reuse.
	*/
	const adjustCellBackgroundStyling = ( function() {
		//dynamic styleSheet currently in use
		var currentCellBackgroundCSS = null;

		// the simplest case (odd number of columns) is stored apart
		var oddColumnCountCSS = null;

		/* this object caches the  generated styleSheets
		 – key: the number of columns the CSS is used for
		*/
		var CSScache = {};

		return function(nbColumns) {
			var CSStoAdd;

			if ( 1 == ( nbColumns & 1 ) )
			// nombre impair de colonnes – règle unique
			{
				if ( null == oddColumnCountCSS )
				{
					oddColumnCountCSS = document.createElement('style');
					oddColumnCountCSS.textContent =
						'.cell:nth-child(odd) { background-color: var(--cell-coul2) }';
				}
				CSStoAdd = oddColumnCountCSS;
			}
			else
			//nombre de colonnes pair : we first look into the cache
			// for the corresponding styleSheet,
			// and if not found we build it
			{
				if ( null == CSScache[nbColumns] ) // reminder: null == undefined
				{
					CSScache[nbColumns] = createCheckerboardCSSforColumns(nbColumns);
				}
				CSStoAdd = CSScache[nbColumns];
			}

			//final application
			if (null != currentCellBackgroundCSS)
			{
				document.body.removeChild(currentCellBackgroundCSS);
			}

			document.body.appendChild(CSStoAdd);
			currentCellBackgroundCSS = CSStoAdd;
		}
	})();


	function createBorderCellCSSforColumns(nbColumns) {
		let newCSS = document.createElement('style'),
			text = '';

		const prefix = '.cell:nth-child(',
			  suffix = ') { border: 4px solid ';

		text += prefix + nbColumns + 'n' + suffix +  'red } ' +
				prefix + nbColumns + 'n+1' + suffix + 'blue }';

		newCSS.textContent = text + suffix;
		return newCSS;
	}


	const adjustBorderCellSelector = (function() {
		var CSScache = {},
			currentBorderCellCSS = null;

		return function(nbColumns) {
			var CSStoAdd;

			if ( null == CSScache[nbColumns] )
			{
				CSScache[nbColumns] = createBorderCellCSSforColumns(nbColumns);
			}
			CSStoAdd = CSScache[nbColumns];

			if (null != currentBorderCellCSS)
			{
				document.body.removeChild(currentBorderCellCSS);
			}

			document.body.appendChild(CSStoAdd);
			currentBorderCellCSS = CSStoAdd;
		}
	})();


	function labelizeCells(cellList, nbColumns)
	{
		for ( let i = 0; i < nbCells;) {
			for (let x = 1; x <= nbColumns; ++x, ++i) {
				cellList[i].textContent = 'col n°' + x;
			}
		}
	}


	// resizeHandler() is a function wrapping its "static local"-like variables
	// inside a closure, and created throught an IIFE
	const resizeHandler = ( function() {
		lastWindowWidth = -1;
		lastColumnCount = 0;
		columnCounter = document.getElementById('column-count');

		return function() {
			// we care only on width changes
			if ( lastWindowWidth == window.innerWidth )
				return;
			lastWindowWidth = window.innerWidth;

			let nbColumns = getColumnCount(cellList);
			if ( lastColumnCount == nbColumns )
				return;
			lastColumnCount = nbColumns;

			columnCounter.textContent = nbColumns;
			adjustCellBackgroundStyling(nbColumns);
			adjustBorderCellSelector(nbColumns);
			labelizeCells(cellList, nbColumns);
		}
	})();


	// MAIN()
	window.addEventListener('resize', resizeHandler);
	resizeHandler();
})
