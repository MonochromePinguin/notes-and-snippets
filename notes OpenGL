â— L'ORDRE DES OPÃ‰RATIONS D'INITIALISATION EST TRÃˆS IMPORTANT.

â— pour accÃ©der Ã  une texture d'entiers (par ex, Â« format interne GL_R32UI,
 format GL_RED_INTEGER, type de composante GL_UNSIGNED_INT Â») dans un shader :
Il faut un usampler2D/usampler2DRect (pour entier),
 isampler2D/ isampler2DRect (pour entier signÃ©) ...
Et on doit utiliser un champs de texture() :
		val = texture(tex,coo).r dans le cas â†‘ de Â«GL_RED_INTEGERÂ».

â— la plupart des fonctionnalitÃ©s doivent Ãªtre activÃ©es :
 pour oGL < 3 :
	glEnable(GL_TEXTURE_2D)
	glColorPointer()/glEnableClientState(GL_COLOR_ARRAY),
	glTexCoordPointer()/glEnableClientState(GL_TEXTURE_COORD_ARRAY)
	etc.

â€¢ glXMakeCurrent() doit Ãªtre appelÃ© avant les fÂ° de manipulation des matrices
de transformation ( glOrtho(), glLoadIdentity() etc.) ;

â— Par souci d'Ã©conomie de mÃ©moire, il faut dÃ©tacher & dÃ©truite les objets shaders
 une fois qu'ils ont Ã©tÃ© compilÃ©s & liÃ©s en un programme, Ã  moins qu'ils ne
 doivent servir Ã  nouveau.


â€¢ pour utiliser un Vertex Buffer Object avec Vertex Array Object, il faut
 d'abord lier le VAO, puis lier/charger les donnÃ©es du VBO :
 l'Ã©tat rÃ©sultant du VBO dÃ©pend du VAO liÃ© au moment de sa crÃ©ation !
â†’ donc :
Â 	glBindVertexArray
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ...)
	glBufferData(	""		""		"", ...)
	glBindBuffer(GL_ARRAY_BUFFER, ...)
	glBufferData(	""		""		"", ...)
	glVertexAttribPointer/glEnableVertexAttribArray x ğ‘›
â€¢ les VAO ne sont pas partageable entre contextes, au contraire des VBO et des IBO.


â€¢ extensions utiles (intÃ©grÃ©es aux versions > 2.1) :
	_ GLX_SGI_swap_control	(pour attendre le rafraichissement vertical)
	_ GL_ARB_debug_output	(permet d'enregistrer, via glDebugMessageCallbackARB(),
	 une cb rappelÃ©e en cas de problÃ¨me etc.)
	_ GL_EXT_compiled_vertex_array
		(verrouille un VAO et permet certaines optimisations)
	_ GL_ARB_clear_texture

â— extensions Ã  examiner :
	GL_AMD_pinned_memory
	ARB_get_program_binary (pr mettre en cache les programmes compilÃ©s)
	GL_ARB_copy_image (copie rapide entre buffers non liÃ©s)
	NV_texture_barrier
	GL_ARB_texture_storage
	GL_ARB_separate_shader_objects
	GL_ARB_cl_event (synchronisation avec openCL)
	GL_ARB_draw_indirect
	GL_ARB_draw_buffers
	GL_ARB_direct_state_access


