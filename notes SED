â— cf Â§4.2 et Â§5 de Â«SED and AWK (2nd Edition), O'ReillyÂ» !

â— OPTIONS :
Â  -i : pour travailler sur des fichiers.
  	Â« sed -i 's/xx/yy/g' fichier Â» va travailler dans Â«fichierÂ»
  -n : par dÃ©faut, ne rien afficher sauf si demandÃ©.
  -r : utilise les expressions rationnelles par dÃ©faut.
	â†’ plus besoin d'Ã©chapper les opÃ©rateurs (, ), | !


â— octet null dans une expression SED :
	Tout simplement Ã©crire \x0 ...


â—SÃ‰LECTEUR D'ADRESSE :
Â  /xxx/		â†’	toutes les lignes contenant le motif xxx
  /xxx/!	â†’	toutes celles ne le contenant PAS (le drapeau s'applique
					Ã  toutes sÃ©lections d'adresse)
/xxx/,/xxx/	â†’	toutes les lignes de la 1e Ã  contenir le 1er motif Ã  la 1e
					contenant le 2nd
  ğ‘›			â†’	ligne ğ‘› (Ã  partir de 1)
  ğ‘›,ğ‘›		â†’ 	lignes ğ‘› Ã  ğ‘›
  $			â†’	derniÃ¨re ligne du texte

on peut bien sÃ»r faire des mÃ©langes avec ğ‘›,ğ‘› :
  /aaa/,$	1,/bbb/

â€¢ on peut imbriquer des sÃ©lecteurs d'adresse via un bloc d'instructions :
	/^BEG.*END/,/^BEG/ {
		# b (Â«branchÂ») â†’ saute Ã  la fin du script si on est en section Â«xxxÂ»
		/^BEGxxxEND/b;
		[commandes Ã  rÃ©aliser dans une section xxx]
	}
	/^BEGxxxEND/,/^BEG/ {
		[commandes Ã  rÃ©aliser dans une section non-xxx]
	}

â— QUELQUES COMMANDES :
q	â†’ quitter

d	â†’ supprimer la ligne

N	â†’ ajouter la ligne suivante au tampon d'entrÃ©e puis redÃ©marre l'analyse

n	â†’ imprime la ligne, "	"	"	"  puis continue l'analyse,
 	  sans revenir au dÃ©but du script

:ğ‘›ğ‘›	â†’  label ğ‘›ğ‘›
bğ‘›ğ‘›	â†’	branch ğ‘›ğ‘›
b	â†’	branch Ã  la fin du script

Â a\â‚™â‚™â‚™	â†’ ajoute â‚™â‚™â‚™ aprÃ¨s la ligne correspondante
Â i\â‚™â‚™â‚™	â†’ insÃ¨re â‚™â‚™â‚™ avant la ligne
Â c\â‚™â‚™â‚™	â†’ replace la/les lignes
		/^aaa/,/zzz$/ c\ttt	â†’ remplace toutes les lignes entre la 1Ã¨re Ã  contenir aaa en dÃ©but de ligne et la 1Ã¨re Ã  contenir zzz en fin de ligne par UNE SEULE occurence de ttt
		/aaa/ { c\xxx \n

Â  y/abc/ABC/	â†’ transforme comme tr !
  =
  r
  w

â€¢commandes de tampon :
h/H		copier/ajouter espace de motif vers retenue
g/G		copier/ajouter retenue vers espace de motif
x		Ã©changer les 2 espaces


â— drapeaux de la commande s:
Â  g
  p
 mais aussi
  gp 		(combinaison de g & de p)
  ğ‘› (1 Ã  255)	â†’ ne remplacer que la ğ‘›iÃ¨me occurence
  w fic		â†’ imprimer l'espace de motifs (la ligne sur laquelle on travaille actu') dans Â«ficÂ»


â— CARACTÃˆRES SPÃ‰CIAUX :
Les expressions rationnelles de SED sont un (grand) /s-ensemble des BRE
 (Â«Basic Regular ExpressionÂ» de POSIX).
â€¢ dans la partie remplacement de la commande s :
Â  &	â†’ toute la correspondance
  \ğ‘›	â†’ "la ğ‘›iÃ¨me sous-chaÃ®ne (partie entre parenthÃ¨se) de la correspondance"

â€¢ dans la partie motif :
Â  $	â†’ fin de ligne,
  ^	â†’ dÃ©but de ligne,

â€¢ Classes de caractÃ¨res / expressions entre crochets :
	[Î±-Î²]	â†’	chaque caractÃ¨re de l'intervalle de Î± Ã  Î²
  _ et classes de caractÃ¨res
 (ici au sein d'une classe englobante, d'oÃ¹ les crochets supplÃ©mentaires) :
	[[:alnum:]]   [[:cntrl:]]   [[:lower:]]   [[:space:]]
	[[:alpha:]]   [[:digit:]]   [[:print:]]   [[:upper:]]
	[[:blank:]]   [[:graph:]]   [[:punct:]]   [[:xdigit:]]
  (plus d'autres dÃ©pendantes de la locale)



â— parenthÃ¨ses permettant de retenir une partie de l'expression  :
si l'option -r n'est pas utilisÃ©e, les parenthÃ¨ses doivent Ãªtre Ã‰CHAPPÃ‰ES,
comme le numÃ©ro de correspondance (qui, lui, l'est toujours) :
	sed -n	's/.*IPAddress:\([0-9\.]*\).*/\1/p'
ou
	sed -rn 's/.*IPAddress:([0-9.]*).*/\1/p'
 â†’ l'ensemble de la ligne lue est remplacÃ© par la correspondance nÂ°1,
 qui est l'adresse IP dÃ©couverte aprÃ¨s Â«IPAddress:Â», puis imprimÃ©.



â— exÃ©cuter plusieurs commandes aprÃ¨s une condition :
	les mettre entre accolades.



â— imprimer 1e occurence trouvÃ©e puis quitter :
	sed -rn '/^PIDFILE=(.+)/ { s//\1/p; q }'
rechercher ligne contenant le motif, puis exÃ©cuter le bloc d'instructions contenant
	" remplacer rien par la sÃ©lection, imprimer, quitter ".


â— BOUTS DE CODE :

â€¢	sed -n '/name:.*usb.*/ s/\(.*name: <\)\|>//g p'
est Ã©quivalent Ã 
	sed -rn '/name:.*usb.*/ s/(.*name: <)|>//g p'
et transforme
	name: <x.usb.y>
en
	x.usb.y

â€¢ entourer un Ã©lÃ©ment HTML <img> PRÃ‰CÃ‰DÃ‰ UNIQUEMENT DE BLANCS SUR SA LIGNE
 par un Ã©lÃ©ment <script> :
_ La conservation de l'indentation (via l'utilisation de 2 groupes de recherche)
 ne marche QUE si <img> n'est prÃ©cÃ©dÃ© que de blancs
_ la balise peut s'Ã©tendre sur plusieurs lignes
_ l'indentation est amÃ©nagÃ©e
	sed -r '/<img/ {
				:bcl
				N
				/<img[^>]+>/ {
					s/\n([[:blank:]]+)/\n\t\1/g
					s/([[:blank:]]+)(<img[^>]+>)/\1<script>\n\t\1\2\n\1<\/script>\n/
					b
				}
				b bcl
			}' <fichier> > <nouvelleVersion>
_ en bref :
	boucle Â«:bclÂ» : addition de la derniÃ¨re ligne lue tant que la balise en
tampon n'est pas fermÃ©e par son '>',
	1er s/.../.../g : on rajoute une tab en dÃ©but de chaque ligne
	2e s/.../.../ : les balises englobantes sont correctement indentÃ©e
grÃ¢ce au 1er groupe de recherche.


â€¢ imprime la liste des utilisateurs du systÃ¨me ayant une session X11 Ã  leur nom :
ck-list-sessions
 | sed -rn "s/[[:blank:]]//g;
	    s/$/\+/g;
	    s/.*:\+($)|realname='([^']*)'|x11-display=('[^'].*')/\1\2\3/p;"
 | tr '\n' '+'
 | sed -r "s/[^'+]*\+\+\+/\n/g; s/\++/ /g"

le 1er sed supprime les blancs, ajoute un plus Ã  chaque fin-de-ligne, puis affiche un saut de ligne pour chaque entrÃ©e, son identifiant utilisateur, son display X11,
le tr suivant remplace les sauts de ligne par des plus,
et le dernier sed remplace les id n'Ã©tant pas suivis par un nÂ° de display entre apostrophes par un +, puis supprime tout les plus.
