principalement liÃ©es au C / Makefile.
Voir notes spÃ©cifiques pour autres langages.

â™¦ Pour un APU A8 d'AMD, gcc 4.6 accepte l'option Â«-march=amdfam10Â»
 (qui correspond Ã  la famille 10h, alors que le A8 est de la 12h ...),
ou mieux Â« -march=native Â»

â— signaux SIGINT, SIGTERM, SIGQUIT, ... & SIGKILL :
â”Œâ”€â”€â”€â”€â”€â”€â”€
â”‚Â  SIGTERM : demande polie de terminaison.
â”‚  SIGINT : GÃ©nÃ©rÃ© par Ctrl-C. demande de terminaison Â«immÃ©diateÂ».
â”‚  SIGQUIT : "	"   Ctrl-\. Contexte de dÃ©bogage : gÃ©nÃ¨re un core dump.
â”‚	 La cible devrait se terminer ss nettoyage - ss refermer les fichiers
â”‚	 ouverts, ni supprimer les fichiers temporaires, ...
â”‚  SIGKILL : ...
â””â”€â”€â”€â”€â”€â”€â”€



â—â—â— - "NULL" est utilisable via un #include <stddef.h> ou <stdlib.h>,
le type "bool" via un #include <stdbool.h>,
les "int32_t" & consorts via <stdint.h>,
 ...

â— CONSTANTES EN C :
 les constantes binaires dÃ©butent par le prÃ©fixe 0b !

â— manips de base :
â€¢ Turn off the rightmost 1-bit :
	(Â¿ pq pas Â« y = x & ~1 Â» ?)
	y = x & (x-1)
â€¢ Isolate the rightmost 1-bit :
	(? pq pas y = Â« x & 1 Â» ?)
	y = x & (-x)
â€¢ Right propagate the rightmost 1-bit :
	y = x | (x-1)
â€¢ Isolate the rightmost 0-bit :
	y = ~x & (x+1)
â€¢ Turn on the rightmost 0-bit :
 	y = x | (x+1)
et, bien sÃ»r, Â« x ^ y Â» veut dire Â« x XOR y Â» !


â— CONVERSIONS CHAINE DE CARACTÃˆRE / NOMBRE en C :
	Â«atoi()Â»,
	Â«scanf()Â», Â«sscanf()Â» (qui sont plus complexes/souples que la prÃ©cÃ©dente).

â€¢SSi on doit convertir UN SEUL octet dont on SAIT qu'il appartient Ã  [0..9] :
	Â« char car = nb  + '0'; Â» et Â« char nb = car - '0'; Â»
(ceci est GARANTI par le standard C - les caractÃ¨res '0' Ã  '9' doivent Ãª consÃ©cutifs)


â— MACROS VARIADIQUES ET __VA_ARGS__ :
	#define fonc(param1, ...) autreFonc( p, param1, ##__VA_ARGS__ )
le double-diÃ¨se permet de supprimer la virgule prÃ©cÃ©dente si la macro est
 appelÃ©e avec un seul argument.


â—MODIFICATEURS NOTABLES DE printf() :
Â 	%.ğ‘›s	â†’ n'affiche que les ğ‘› premiers caractÃ¨res de la chaÃ®ne.
	%.*s	â†’ n'affiche d'une chaÃ®ne que le nombre de caractÃ¨res indiquÃ© par la
	 variable passÃ©e en param :
		printf("une chaÃ®ne : %.*s\n", nbCarAAfficher, chaÃ®ne);

â€¢ afficher un nb hexa :
Â 	%x, %X	â†’ affiche un hexa en minuscules/majuscules,
	%#x	â†’ avec le prÃ©fixe Â« 0x Â»,
	%0ğ‘›X	â†’ sur ğ‘› colonnes (comblÃ© de 0)
	%ğ‘›X	â†’ sur ğ‘› colonnes (comblÃ© d'espaces)
 par ex :
 	%#016X == Â« afficher un hexa en majuscules sur 16 colonnes comblÃ©es par 0 Â»


â— il faut en thÃ©orie un "#define _REENTRANT" avant tout en-tÃªte pouvant fournir
 des fonctions rÃ©entrantes, Ã  utiliser avec les threads ; cpd, cela est fait en
 standard dans la glibc, d'oÃ¹ inutilitÃ© en pratique ...
CEPENDANT, malloc() ne tient compte que des threads lancÃ©s par pthread.
 Ã€ ne pas utiliser avec clone() donc !
MÃªme si _REENTRANT est dÃ©fini, il y a des bogues si utÂ° de malloc() avec clone()
 sans synchronisatÂ° explicite !
 â†’ avec clone(), on peut par ex allouer la mÃ©m via mmap().


â— typedef struct { XXX } YY :
Lors de la dÃ©claratÂ° de variables du type YY, pas de "struct",
 sinon c'est considÃ©rÃ© comme la dÃ©claration d'un type incomplet !!!

â™¦ structure autorÃ©fÃ©rencielle (avec pointeurs pour liste chaÃ®nÃ©e par ex.) :
 Â« typedef struct XXX { aaa; struct XXX *ppp; } XXX Â»
le Â«tagÂ» (entre Â«structÂ» et les accolades) peut Ãª le mÃªme q l'id. de la structure ...


â— TRANSTYPAGE DE STRUCTURES POINTÃ‰ES :
 struct { xxx } YY;
 ZZ* pointeur;
AccÃ©der Ã  un champ d'un ptr transtypÃ© en YY se fait :
 	vv = ((struct YY*) pointeur)->xxx

â— TRANSTYPAGE POINTEUR/ENTIER :
â€¢ pour passer d'un entier 32b Ã  un pointeur 64b :
	(char*) (intptr_t) entier;
Le type Â« intptr_t Â» est dÃ©fini dans Â« stdint.h Â»


â— STRUCTURE OU LISTE AD-HOC EN PARAMÃˆTRE DE FONCTION :
Ã©crire
	fonc( (strucXXX) {aa, bb, cc} );
p.ex :
	execve( "nomProg", (char* []) {"nomProg", "param1", "param2", NULL}, NULL);
	return( (recLien){.retour = FALSE} ); //ici, seul le champs "retour" du recLien est initialisÃ© ...
OU, dans le cas d'un pointeur vers une structure :
 - avec la dÃ©finition "getutid( struct utmp *ut );", il faut
	p = getutid( & (struct utmp) {ut_type: RUN_LVL} ); //pareil, seul ce champ ...
 - mais avec "fonc( recParams *params );", sans le mot "struct", il faut
 	fonc( & (recParams) {nom: blabla} );, sans le mot "struct" !!!

â— Â«INITIALISEURSÂ» DE TABLEAUX :
- Pour donner Ã  un ou des intervalles d'entrÃ©es d'un tableau la mÃªme valeur :
	tableau[nbEntrÃ©es] = { [0 ... n] = val1, [x ... y ] = val2 };
- ou pour initialiser seulement certaines entrÃ©es (le reste Ã©tant mis Ã  zÃ©ro) :
	tableau[i] = { [a] = v1, [b] = v2 };

â— TABLEAUX DE LONGUEUR VARIABLE :
Â«	void fonc( int a )
	{
		char tbl[ a * 2 ];
		...
Â»


â— VARIABLE DE TYPE "POINTEUR VERS FONCTION" EN PARAMÃˆTRE :
Ã©crire
	fonc( typeRetr (*NomDeLaFonctionEnParam) (aa, bb, cc) );
p.ex :
	void chargeur(char* fic, void (*parseur)(char*, int), int v );


â—DÃ‰FINITION DE FONCTIONS Â«INLINEÂ» utilisÃ©e dans d'autres unitÃ©s de compilation :
Â«extern inlineÂ» dans le .h inclus dans les autres fichiers source,
et simplement Â«inlineÂ» dans le .c oÃ¹ la fonction est dÃ©finie ...


â— POUR COMPILER UNE BIBLIOTHÃˆQUE PARTAGÃ‰E :
â€¢ Utiliser Â«-shared -fpicÂ»Â (Â«-fPICÂ» peut, suivant la plate-forme, produire
 un code moins efficient [mais soumis Ã  moins de limitations] ...)

â€¢ EXPORTATION DE SYMBOLES D'UNE BIBLIOTHÃˆQUE & OPTIONS DE COMPILATION DE GCC :
Si l'option Â«-fwhole-programÂ» est utilisÃ©e, les fonctions non rÃ©fÃ©rencÃ©es
 dans le code seront Ã©liminÃ©es ...
                                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â†’ les fonctions Ã  exporter doivent avoir l'â”‚attribut Â«usedÂ»â”‚
 pour Ãªtre prÃ©servÃ©es !                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â™¦ Pour limiter le nombre de symboles exposÃ©s dans la bibliothÃ¨que,
 utiliser l'option GCC Â«-fvisibility=internalÂ» (qui rend les symboles
 Â«privÃ©sÂ» par dÃ©faut), et indiquer
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 les symboles Ã  exporter par l'attribut Â«â”‚visibility=("default")â”‚Â»
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â— Au contraire, compiler avec l'option Â« -rdynamic Â» inclut les rÃ©fÃ©rences Ã  de
 nombreux symboles ds le binaire, ce qui permet d'utiliser les fÂ°s
 d'affichage de stacktrace Â« backtrace() Â» et Â« backtrace_symbols() Â»
Â fournies par execinfo.h ...




â™¦ CONVERSIONS TEXTE/ADRESSE IP :
   inet_ntop, inet_pton  -  adresses IP4/IP6 binaire<=>texte ;


 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â—â”‚ NOTES GTK :â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
- "gtk_ui_manager_set_add_tearoffs (ui_manager, TRUE);"
	permet d'avoir des menus dÃ©tachables; Ã  placer aprÃ¨s l'init du ui_manager,
par ex Ã  l'init de la classe de fen.

â€¢ la moindre rÃ©fÃ©rence Ã  un chaine d'un objet descendant de Gobject doit passer par une copie & g_free() !

â€¢ on peut associer des donnÃ©es supplÃ©mentaires Ã  n'importe quel widget :
	g_object_set_data(obj, "nomPropriÃ©tÃ©", valeur);
â†’ valeur retrouvÃ©e par
	g_object_get_data(ob, "nomPropriÃ©tÃ©");


â€¢ Quand on utilise "gtk_tooltip_set_text()", la chaÃ®ne passÃ©e en
param ne doit pas Ãªtre dÃ©sallouÃ©e : il n'y a apparemment pas de copie interne.
Donc PAS de g_free() si elle est obtenue, par exemple, via un
 gtk_tree_model_get() ou assimilÃ© renvoyant une chaÃ®ne copiÃ©e et
 Ã  dÃ©sallouer ...

â€¢ Le signal Â«notifyÂ» est Ã©mis lorsqu'une propriÃ©tÃ© d'un objet change ...
Â & pas forcÃ©ment un widget (Ã§Ã  marche aussi sur les GtkTreeViewColumn)

â€¢ Le signal Â«query-tooltipÂ» d'un gtkTreeView est renvoyÃ© Ã  chaque mvt
 du pointeur !
Et il faut Ã€ CHAQUE FOIS armer le texte de la bulle, sinon elle apparait vide.

â€¢ Le signal Â«keynav-failedÂ» d'un GtkTreeView n'est pas envoyÃ© qd la navigation
 horizontale bute contre les bordsÂ - il l'est pd la naviguÂ° verticale ...

â€¢ Â« gtk_widget_has_focus(un GtkTreeView) Â» rv faux lorsqu'on est
 dans la ligne d'entÃªte.

â€¢ les GError* doivent Ãª libÃ©rÃ©s par Â«g_error_free()Â» aprÃ¨s usage !


â— NOTES SUR L'UTILISATION DES GIOChannel :
La sÃ©quence de nettoyage correcte est
	g_source_remove() s/ la ref-fournie-par-g_io_add_watch
	g_io_channel_shutdown()	â†’ QUI FERME LE DESCRIPTEUR DE FICHIER SOUS-JACENT !
	g_io_channel_unref()
â†’ donc PAS de XCloseDisplay() final si on a obtenu le GIOChannel via
	g_io_channel_unix_new( XConnectionNumber(disp) )


â— NOTES sur les Ã©ven. de Â«G_FILE_MONITORÂ» :
Â«G_FILE_MONITOR_EVENT_CREATEDÂ»Â est renvoyÃ© lorsqu'un fichier est crÃ©Ã©
 OU lorsqu'un fichier est dÃ©placÃ© vers notre rÃ©pertoire surveillÃ©,
Â«G_FILE_MONITOR_EVENT_DELETEDÂ»Â lorsqu'il est dÃ©truit OU dÃ©placÃ©
 vers un autre rÃ©pertoire,
et Â«G_FILE_MONITOR_EVENT_MOVEDÂ» lorsqu'il est renommÃ© !



â— NOTES SUR  WAITPID() & GESTIONNAIRE DU SIGNAL SIGCHLD :
	Â¿Â¿Â¿ Dans Â«lanÃ§eur-serviceÂ» ,qui utilise Ã  la fois waitpid() et un gestionnaire du signal SIGCHLD,
le gestionnaire de signal est toujours appelÃ© avant que waitpid ne rende la main ;
	cependant, est-ce un comportement standard (c'est en tout cas le plus efficient), ou bien rien
 n'interdit que waitpid() ne retourne AVANT que le gestionnaire de signal ne s'exÃ©cute ???



â— NOTES UTMP & RUNLEVEL :
- Apparemment, il n'y aurait qu'un enregistrement de ce type ds utmp,
et les niveaux y sont enregistrÃ©s sous forme de char dans ut_id :
 le niveau actuel dans l'octet de poid faible ( ut_id % 256 ),
 et le prÃ©cÃ©dent dans le 2e octet ( ut_id / 256 ).



â— FONCTIONS NOTABLES EN C:
_ malloc(), calloc(), alloca(),
 valloc(), memalign()/posix_memalign(),
 mincore() qui dÃ©termine les pages prÃ©sentes en mÃ©m hysique,
 sbrk()/brk() ;
_ madvise() (qui ne fonctionne pas avec les projection MAP_ANONYMOUS) ;
 mallopt() change le comportement de malloc() & Cie;
_ posix_fadvise(), readahead(), fallocate() ;
_ readv() & writev() - E/S en tampons fractionnÃ©s ;

_ les timerfd(), eventfd(), signalfd(), ...



â— POUR CONNAITRE LES MACROS PRÃ‰DÃ‰FINIES par GCC :
Â«touch tmp.h; gcc -dM -E tmp.hÂ» (-dM AVEC un fichier liste toutes les macros qui y sont dÃ©finies plus les macros dÃ©f' par GCC, SSI -E est aussi spÃ©cifiÃ©).


â— OPÃ‰RATEURS EN C & Cie :
 ~ x : complÃ©ment Ã  un == inversion bit-Ã -bit
 x ^ y : OU EXCLUSIF / Â«XORÂ»
 Et bien sÃ»r |= &= etc.


â— AVERTISSEMENTS DE GCC :
â™¦ Â«initialization discards `const' from pointer target typeÂ» :
	un pointeur vers une chaÃ®ne Â«constÂ» est utilisÃ© en paramÃ¨tre ; il faut redÃ©finir ce pointeur, bien sÃ»r s'il ne sert pas Ã  la modifier, comme Â«const char*Â».
â™¦ Â«incompatible implicit declaration of built-in function XXXÂ» :
	il n'y a pas de prototype (pas d'entÃªte .h inclu ! ) pour la fonction utilisÃ©e, et, sans prototype, le type de retour est implicitement dÃ©fini comme "int".



â— NOTES MAKEFILE :
â€¢ Les noms avec des espaces doivent Ãªtre Ã©chappÃ©s :
	"parseur\ config.h" est correct
â€¢ pour utiliser des noms de fichier commenÃ§ant par des espaces dans une var:
dÃ©finir une variable ne contenant rien
	vide :=
puis prÃ©fixer les variables contenant le nom de fichier problÃ©matique :
	$(vide)$(fic)

â€¢ cibles multiples d'une recette :
	cible1 cible2 cible3 : [dÃ©pendances]
		... recette ...
â€¢ variable locale Ã  une cible (Â«target specificÂ») :
cible: VAR=valeur
Ã€ PART de la dÃ©claration de la recette

â™¦ Chaque commande d'une cible (par ex, Â«uninstallÂ») est exÃ©cutÃ©e dans un
 sous-shell,
Â et donc les changements au sein de son environnement ne sont pas exportÃ©s.
De ce fait, la commande Â«cd XXXÂ» change bien de rÃ©pertoire, mais la commande
 suivante est effectuÃ©e ds le rÃ©pertoire initial ...
3 solutions :
â€“ utiliser une LISTE de commandes : Â«cd XXX; rm X Y ZÂ»
â€“ mettre un Â« \ Â» Ã  la fin de ttes lignes Ã  joindre en 1 seule commande
â€“ dÃ©finir .ONESHELL â†’ un seul shell par recette

â€¢Substitution de commande shell : Â«$(shell <commande> )Â»
â€¢

â€¢ ne pas afficher une commande shell :
En la prÃ©fixant par un arobase !
	@comm xxxx

â€¢ dÃ©finition des variables :
 =
	variable substituÃ©e Ã  chaque invocation â€“ si elle fait rÃ©fÃ©rence Ã  d'autres
	  variables, la variation des valeurs de celles-ci est prise en compte â€“

 +=
 =+
	ces 2 opÃ©rateurs suffixent/prÃ©fixent la variable AVEC UN ESPACE
 xxx_append = ...
 xxx_prepend = ...
	la mÃªme avec xxx, mais SANS espace
 :=
	variable substituÃ©e Ã  l'assignation puis inchangÃ©e
 ?=
	valeur assignÃ©e si variable non dÃ©finie ("unset"), mais pas si la variable
	  existe mais est de valeur nulle
 !=
	HORS D'UNE RECETTE (car dans une recette c'est la syntaxe shell qui est
	  utilisÃ©e ...), assigne le code de retour d'un programme Ã  la variable
	Dans une recette, mieux vaux utiliser $(eval VAR=prog...)
â€¢ export VARÂ  exporte une variable du makefile vers les commandes exÃ©cutÃ©es


