	┏━━━━━━━━━━━━━┓
	┃ NOTES JAVA :┃
	┗━━━━━━━━━━━━━┛

● COMPILER EN CLI :
avec telle structure de dossier & classes :
	.
	├ Manifest (fichier manifest)
	└ src
	  └ com
	    └ monochrome
	      └Main.java

	javac -classpath src src/com/monochrome/Main.java
	jar cfm package.jar Manifest -C src com

• javac :
compile chaque fichier « .java » en bytecode « .class »
	-classpath : le chemin où trouver l'arborescence des classes
•jar :
	jar cfm [nomPaquetageÀproduire] [nomManifest] -C [dossierSources] [racineEspaceDeNommage]
créé le «.jar».
	c	: ℂréer paquetage
	f	: on indique le nom du paquetage créé – 1er argument
	m	: tirer les attributs du fichier à créer du fichier donné en 2e argument



● FICHIER .java :
en-tête (imports, déclaration de package)
définition de la classe – contenant le corps de la classe

public class ... {
    //s'il y a un main
    public static void main(String[] args) {
        ...
    }
}
• plusieurs classes dans un même fichier ?
Par convention, une seule classe publique par fichier.



● LITÉRAUX :
    0b0010101       0b  binaire
    0xA154FA4       0x  hexa
    1.0f              f virgFlot
    
┃• les nombres peuvent être formatés avec des soulignés en java ≥7 :
┃	double v = 1_000_000d;

• caractères d'échappement :
    \n
    \r
    \t
    \b (backspace)
    \f (saut de page)


● OPÉRATEURS :
    +=  *=  %=
    &  |    ^ (XOR)    ~ (NOT « complémentation »)
    >>   <<    SIGNÉS
    >>>    <<<  NON-SIGNÉS
    
  
● COMPOSITION / AGGRÉGATION :
• composition :
    un élément fait partie de l'autre (durée de vie, exclusivité)
• aggrégation :
    un élément a possède un autre élément b (mais b peut se passer de a)
   
    
● POLYMORPHISME / SURCHARGE / COVARIANCE :
•surcharge :
    _ différentes signatures pour une même méthode
    _choix de la méthode à la compilation;
• polymorphisme :
    _ même signature
    _ redéfinition d'une méthode au sein d'une arborescence de classes
    _ choix à l'exécution en fonction de la classe de l'objet.
• covariance :
    quand une méthode surchargée dans une classe-fille retourne une
classe dérivée de celle renvoyée par la méthode de la classe-mère.


● ATTRIBUTS DANS UNE INTERFACE :
    STATIC FINAL PAR DÉFAUT !


● UPCASTING / DOWNCASTING :
• upcasting :
    classe fille vers classe parente ;
    implicite lors d'une assignation classeParent = classeEnfant.
• downcasting : classe parent vers classe fille.
    sans downcasting, la JVM vérifie à l'exécution la correspondance des types.
    avec: pas de tests.


● VARIABLE D'INSTANCE :
    Tt paramètre passé au constructeur d'un objet est une « variable d'instance »


┏━━
┃•comparaison de chaines :
┃	« == tests for reference equality. (useful for interned strings)
┃	 .equals() tests for value equality. »
┃
┃• ne pas oublier la syntaxe «for( compteur : iterable )» :
┃	int[][] tbl = { { 1, 2, 3}, {10, 20, 30} };
┃	for ( int[] sousTableau : tbl )
┃		for ( int entier : sousTableau )  ← la boucle englobante renvoit un
┃			blablabla		                int[] dans «sousTableau»


● MODIFICATEURS DE VISIBILITÉ DES CLASSES ... :
	«par défaut» → tout le paquetage
	public

● ... ET DES ATTRIBUTS & MÉTHODES :
	private		    →	privé à la classe
	«par défaut»	→	tout le paquetage
	protected	    →	paquetage et descendance de la classe
	public

• static :
	s/ membre ou méthode :	commun à la classe ;
				pas d'accès aux champs d'instances.
	s/ bloc d'initialisation - exécuté au chargement de la classe.
	s/ classes internes : ↓↓↓

• CLASSES INTERNES :
	«par défaut»	→	chq instance est liée à une instance
						 de la classe conteneur
	static			→	comme membres statiques ...
	classes locales & anonymes :
			utilisables seulmnt ds le bloc de code de déclarat°

• final :
	s/ attribut	→	constante (pour objets : référence constante)
	s/ méthodes →	ne peuvent être redéfinies par descendants
	s/ classe 	→	elle ne peut être dérivée

• static final → constante !



● CONCATÉNATION DE CHAÎNES :
    StringBuilder > StringBuffer > str.concat() > opérateur «+» 



● TRY/CATCH/FINALY:
Chaînage de blocs catch{},
 ou classes d'exceptions multiples dans un même catch, séparées par des «|»;
    try {
        ...
    } catch (ArithmeticException | blablaException e) {
        ...
    } catch (Exception e) {
        ...
    }



● FLUX :
_ .append(), .close(), .write(), ...

InputStream, OutputStream, Reader, Writer et leurs enfants :
    PrintWriter, CharArrayWriter, ... 
_ System.in, System.out

• « new PrintWriter( new FileOutputStream( new File(path) ) ) » :
    try {
        outFile = new File(OUT_FILE);
        PrintWriter writer = new PrintWriter( new FileOutputStream(outFile));

        System.out.println("writing to " + outFile.getAbsolutePath());

        writer.print(...);
        writer.println();

        writer.close();

    } catch (FileNotFoundException e) {
        ...
    }

• JNDI :
    Java Naming and Directory Interface


● COLLECTIONS :
Interfaces implémentées par des objets stockant des objets.
⊕ Set :           € de valeurs non dupliquées.
_ SortedSet :       Set trié.
⊕ List :          € de valeurs consécutives
    .add(val)
    .remove(index)
    .get(index)
⊕ Map :
_ hashmap          tableau associatif (PHP), dictionnaire (python), hash (ruby)
    .put(clef, valeur)
    .remove(clef)
    .get(clef)
• déclarations :
    // avec upcastin implicite 
    Map hash1 = new HashMap<Integer, String>();
ou bien
    HashMap<Integer, String> hash1 = new HashMap<>();


● ITÉRATEURS :
• listes :
    Iterator iter = tblInt2.iterator();
    while (iter.hasNext()) {
        // print the value of the corresponding entry
        System.out.println( iter.next() );

        //remove the entry
        iter.remove();
    }
• Maps :
itérateur et transtypage de iter.next() vers Map.Entry.
   hash1.forEach( (key, value) -> {
            System.out.println(value);
        }
    );

    //MÉTHODE DÉPRÉCIÉE
    Iterator i = hash1.entrySet().iterator();
    while (i.hasNext()) {
        System.out.println( ( (Map.Entry) i.next() ).getValue() );
    }

    //Affiche la paire clef/valeur
    Iterator i = hash1.values().iterator();
    while (i.hasNext()) {
        System.out.println( i.next() );
    }

