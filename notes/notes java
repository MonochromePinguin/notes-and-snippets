	â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
	â”ƒ NOTES JAVA :â”ƒ
	â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

â— COMPILER EN CLI :
avec telle structure de dossier & classes :
	.
	â”œ Manifest (fichier manifest)
	â”” src
	  â”” com
		â”” monochrome
		  â””Main.java

	javac -classpath src src/com/monochrome/Main.java
	jar cfm package.jar Manifest -C src com

â€¢ javac :
compile chaque fichier Â« .java Â» en bytecode Â« .class Â»
	-classpath : le chemin oÃ¹ trouver l'arborescence des classes
â€¢jar :
	jar cfm [nomPaquetageÃ€produire] [nomManifest] -C [dossierSources] [racineEspaceDeNommage]
crÃ©Ã© le Â«.jarÂ».
	c	: â„‚rÃ©er paquetage
	f	: on indique le nom du paquetage crÃ©Ã© â€“ 1er argument
	m	: tirer les attributs du fichier Ã  crÃ©er du fichier donnÃ© en 2e argument



â— FICHIER .java :
en-tÃªte (imports, dÃ©claration de package)
dÃ©finition de la classe â€“ contenant le corps de la classe

public class ... {
	//s'il y a un main
	public static void main(String[] args) {
		...
	}
}
â€¢ plusieurs classes dans un mÃªme fichier ?
Par convention, une seule classe publique par fichier.

â€¢ import static :
â†’ permet de ne pas prÃ©fixer un symbole importÃ© par sa portÃ©e.
	import static Math.*;
ou
	import static Math.PI; //plus spÃ©cifique
	...
	System.out.print(PI); //au lieu de Â« Math.PI Â» â€“ grÃ¢ce au import static



â— ANNOTATIONS :
_ marqueurs / Â«markersÂ» :
	@deprecated

_ paramÃ©trÃ©es / Â«single value annotationsÂ» :
	@SuppressWarning(value = {"unchecked", "deprecation"})

_ multi-paramÃ©trÃ©es / Â«full annotationsÂ»

_ annotations d'annotations :
	@Target,
	@Retention
		Â« RetentionPolicy.SOURCE Â» : Ã©cartÃ© par le compilateur
			.CLASS  : conservÃ© dans le .class, mais pas chargÃ© par la JVM
			.RUNTIME : chargÃ© par la JVM et accessible par rÃ©flexion
	@Inherited,
	...



â— LITÃ‰RAUX :
	0b0010101		0b  binaire
	0xA154FA4		0x  hexa
	1.0f			  f virgFlot

â”ƒâ€¢ les nombres peuvent Ãªtre formatÃ©s avec des soulignÃ©s en java â‰¥7 :
â”ƒ	double v = 1_000_000d;

â€¢ caractÃ¨res d'Ã©chappement :
	\n
	\r
	\t
	\b (backspace)
	\f (saut de page)



â— OPÃ‰RATEURS :
	+=  *=  %=
	&  |    ^ (XOR)    ~ (NOT Â« complÃ©mentation Â»)
	>>   <<    SIGNÃ‰S
	>>>    <<<  NON-SIGNÃ‰S


â— INSTANCIER UNE CLASSE PAR SON NOM :
Class.forName(str) : renvoit une rÃ©fÃ©rence Ã  la classe nommÃ©e en param'
	try	{
		Class classe = Class.forName(nomClasse);
		// RÃ©cupÃ¨re le constructeur prenant en paramÃ¨tre telles classes
		java.lang.reflect.Constructor constructeur = classe.getConstructor(
			// â†“ liste des types des paramÃ¨tres
			new Class[] {Class.forName(nomClasseParam, nomClasseParam, ...})
		);
		// appel avec un tableau de paramÃ¨tres
		constructeur.newInstance(new Object[] { param, param, ...} );
	}
	catch (ClassNotFoundException | NoSuchMethodException
		| InstantiationException
		// â†“ classe abstraite ou interface
		| IllegalAccessException
		// classe inaccessible
		| java.lang.reflect.InvocationTargetException e ) {
		...
	}



â— COMPOSITION / AGGRÃ‰GATION :
â€¢ composition :
NOTION LIÃ‰E AUX INTERFACES.
	un Ã©lÃ©ment fait partie de l'autre (durÃ©e de vie, exclusivitÃ©)
â€¢ aggrÃ©gation :
	un Ã©lÃ©ment a possÃ¨de un autre Ã©lÃ©ment b (mais b peut se passer de a)



â— POLYMORPHISME / SURCHARGE / COVARIANCE :
â€¢surcharge :
	_ diffÃ©rentes signatures pour une mÃªme mÃ©thode
	_choix de la mÃ©thode Ã  la compilation;
â€¢ polymorphisme :
	_ mÃªme signature
	_ redÃ©finition d'une mÃ©thode au sein d'une arborescence de classes
	_ choix Ã  l'exÃ©cution en fonction de la classe de l'objet.
â€¢ covariance :
	quand une mÃ©thode surchargÃ©e dans une classe-fille retourne une
classe dÃ©rivÃ©e de celle renvoyÃ©e par la mÃ©thode de la classe-mÃ¨re.

â€¢ on peut surcharger le constructeur d'une classe, donc :
Pour appeler un autre constructeur dans le constructeur, utiliser Â« this() Â»;
	class c {
		c(p1, p2) {
			this(p1, p2, const);
		}

		c(p1, p2, p3) {
			...
		}
	}


â— prioritÃ©s opÃ©rateurs :
en particulier,
 >> >>> <<    â†’    > <= < <=    â†’    == !=    â†’    || &&


â— UPCASTING / DOWNCASTING :
â€¢ upcasting :
	classe fille vers classe parente ;
	implicite lors d'une assignation classeParent = classeEnfant.
â€¢ downcasting : classe parent vers classe fille.
	sans downcasting, la JVM vÃ©rifie Ã  l'exÃ©cution la correspondance des types.
	avec: pas de tests.


â— VARIABLE D'INSTANCE :
	Tt paramÃ¨tre passÃ© au constructeur d'un objet est une Â« variable d'instance Â»


â— AUTOBOXING :
	Conversion type primitif / type Objet associÃ© â€“ type Â« enveloppeur Â».



â”â”â”
â”ƒâ€¢comparaison de chaines :
â”ƒ	Â« == tests for reference equality. (useful for interned strings)
â”ƒ	 .equals() tests for value equality. Â»
â”ƒ
â”ƒâ€¢ ne pas oublier la syntaxe Â«for( compteur : iterable )Â» :
â”ƒ	int[][] tbl = { { 1, 2, 3}, {10, 20, 30} };
â”ƒ	for ( int[] sousTableau : tbl )
â”ƒ		for ( int entier : sousTableau )  â† la boucle englobante renvoit un
â”ƒ			blablabla							int[] dans Â«sousTableauÂ»


â— MODIFICATEURS DE VISIBILITÃ‰ DES CLASSES ... :
	Â«par dÃ©fautÂ» â†’ tout le paquetage
	public

â— ... ET DES ATTRIBUTS & MÃ‰THODES :
	private			â†’	privÃ© Ã  la classe
	Â«par dÃ©fautÂ»	â†’	tout le paquetage
	protected		â†’	paquetage et descendance de la classe
	public

â€¢ static :
	s/ membre ou mÃ©thode :	commun Ã  la classe ;
				pas d'accÃ¨s aux champs d'instances.
	s/ bloc d'initialisation - exÃ©cutÃ© au chargement de la classe.
	s/ classes internes : â†“â†“â†“

â€¢ CLASSES INTERNES :
	Â«par dÃ©fautÂ»	â†’	chq instance est liÃ©e Ã  une instance
						 de la classe conteneur
	static			â†’	comme membres statiques ...
	classes locales & anonymes :
			utilisables seulmnt ds le bloc de code de dÃ©claratÂ°

â€¢ final :
	s/ attribut	â†’	constante (pour objets : rÃ©fÃ©rence constante)
	s/ mÃ©thodes â†’	ne peuvent Ãªtre redÃ©finies par descendants
	s/ classe 	â†’	elle ne peut Ãªtre dÃ©rivÃ©e

â€¢ static final â†’ constante !

â— PORTÃ‰ES PAR DÃ‰FAUT :
â€¢ attributs dans une interface :
	STATIC FINAL par dÃ©faut
â€¢ enum dans une autre classe :
	STATIC par dÃ©faut



â— MÃ‰THODES VARIADIQUES avec ellipse :
l'argument variadique est un tableau :
	fonc int f(bool i, int ...vars) {
		for (int i : vars) { ... }
		for (int i = 0; i < vars.length; i++) { ... }
	}
â†’ possible de passer un tableau en argument !
	int[] tbl = {1, 2, 3};
	fonc(tbl);



â— TYPES GÃ‰NÃ‰RIQUES :
_ non gÃ©nÃ©rique :
peut stocker n'importe quoi, mais sans type assignÃ© :
	ArrayList lst = new ArrayList();
_ gÃ©nÃ©rique :
	ArrayList<Type> = new ArrayList<>();

â€¢ dÃ©claration :
	Class typeGÃ©nÃ©rique<T, ..., Tğ‘›> {
		T ...;
		Tğ‘› ...;
	}


â— FORMATAGE DE CHAÃNES :
â€¢ format similaire Ã  printf et consorts, mÃªme modificateurs :
	String.format(
		"Cette chaÃ®ne contient un entier Â«%iÂ» & une chaÃ®ne Â«%sÂ»\n,
		unInt,
		uneString
	);


â— CONCATÃ‰NATION DE CHAÃNES :
	StringBuilder > StringBuffer > str.concat() > opÃ©rateur Â«+Â»
â€¢ on peut appeler des mÃ©thodes sur une chaÃ®ne littÃ©rale :
	"blablabla".concat("...")


â— Integer.parseInt(ch), Integer.decode(ch), Integer.value(ch),
  Double.parseDouble(ch), Double.decode(ch), Double.value(ch),
  etc. etc.


â— TRY/CATCH/FINALLY:
ChaÃ®nage de blocs catch{},
 ou classes d'exceptions multiples dans un mÃªme catch, sÃ©parÃ©es par des Â«|Â»;
	try {
		...
	} catch (ArithmeticException | blablaException e) {
		...
	} catch (Exception e) {
		...
	}



â— FLUX :
_ .append(), .close(), .write(), ...

InputStream, OutputStream, Reader, Writer et leurs enfants :
	PrintWriter, CharArrayWriter, ...
_ System.in, System.out

â€¢ Â« new PrintWriter( new FileOutputStream( new File(path) ) ) Â» :
	try {
		outFile = new File(OUT_FILE);
		PrintWriter writer = new PrintWriter( new FileOutputStream(outFile));

		System.out.println("writing to " + outFile.getAbsolutePath());

		writer.print(...);
		writer.println();

		writer.close();

	} catch (FileNotFoundException e) {
		...
	}

â€¢ JNDI :
	Java Naming and Directory Interface



â— COLLECTIONS :
Interfaces implÃ©mentÃ©es par des objets stockant des objets.
âŠ• Set :			   â‚¬ de valeurs non dupliquÃ©es.
_ SortedSet :	   Set triÃ©.
âŠ• List :		   â‚¬ de valeurs consÃ©cutives
	.add(val)
	.remove(index)
	.get(index)
âŠ• Map :
_ hashmap : 	tableau associatif (PHP), dictionnaire (python), hash (ruby)
	.put(clef, valeur)
	.remove(clef)
	.get(clef)
â€¢ dÃ©clarations :
	// avec upcastin implicite
	Map hash1 = new HashMap<Integer, String>();
ou bien
	HashMap<Integer, String> hash1 = new HashMap<>();



â— ITÃ‰RATEURS :
â€¢ listes :
	Iterator iter = tblInt2.iterator();
	while (iter.hasNext()) {
		// print the value of the corresponding entry
		System.out.println( iter.next() );

		//remove the entry
		iter.remove();
	}

â€¢ Maps :
itÃ©rateur et transtypage de iter.next() vers Map.Entry.
   hash1.forEach( (key, value) -> {
			System.out.println(value);
		}
	);

â€¢ ITÃ‰RER Ã€ TRAVERS UN TABLEAU :
les mÃ©thodes statiques .stream() et .asList() permettet de rÃ©cupÃ©rer
 un itÃ©rable :
	Iterator<String> iter = Arrays.stream(tbl).iterator();
		while (iter.hasNext()) {
			System.out.println(iter.next());
		}



	//MÃ‰THODE DÃ‰PRÃ‰CIÃ‰E
	Iterator i = hash1.entrySet().iterator();
	while (i.hasNext()) {
		System.out.println( ( (Map.Entry) i.next() ).getValue() );
	}

	//Affiche la valeur seule / clef seule (avec hash1.keyset())
	Iterator i = hash1.values().iterator();
	while (i.hasNext()) {
		System.out.println( i.next() );
	}



â— ENUM :
N'est PAS une classe !
acceptent des constructeurs et des propriÃ©tÃ©s :
	public static enum Val {
		VAL1, VAL2, ... VALğ‘›;
		ou
		VAL1(...), VAL2(...), VAL3(...);

		public String name;

		Val(String name) {
			this.name = name;
		}
	}
â€¢ enum.values()



â— DateTime et Cie :
â€¢ obtenir date & heure en UTC :
	LocalDateTime.now( Clock.systemUTC() );
oÃ¹ Clock.systemUTC() sera plutÃ´t stockÃ© dans une var ...
