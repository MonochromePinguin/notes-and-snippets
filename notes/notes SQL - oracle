‚óè commandes en ln-d-comm :
‚Ä¢ lister les services accessibles :
	lsnrctl service
¬ø¬ø¬ø apparemment, il existe un service pour chaque PDB ... ???


‚óè LA BDD NE R√âPONDS PAS AU D√âMARRAGE
 ¬´ ERROR : ORA-01033: ORACLE initialization or shutdown in progress ¬ª :
La BdD doit √™tre r√©-ouverte. (¬øpourquoi?)
Ce qui a march√© sous ¬´ sqlplus / as sysdba ¬ª :

_ DERNI√àRE VERSION :
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_2_20181210 OPEN READ WRITE;

_ ANCIENNE VERSION :
	SHUTDOWN IMMEDIATE			# red√©marrer la BdD : ¬ø utile ?
	STARTUP						# ¬ø?
	ALTER SESSION SET CONTAINER = D12UTF8PDB_3_4_1_20181226_516;
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_1_20181226_516 open; ## ¬ø peut-√™tre la seule ligne utile ?



‚óè SQLPLUS :
‚Ä¢ connexion :
sqlplus						‚Üí	√† la BdD par d√©faut
sqlplus <NOM>@<BdD>
sqlplus <NOM>/<MdP>@<BdD>	           moins s√©curis√©
sqlplus <NOM>/<MdP>@//URL:port/service ""   ""


‚Ä¢ ex√©cuter un script :
	sqlplus @<fichier>
‚Ä¢ ex√©cuter un script **avec des param√®tres** :
	@<fichier>  param1  param2  param...
Pour acc√©der √† ces param√®tres de script :
utiliser une esperluette.
	&param1, &param2, ...

‚Ä¢ affichage r√©duit au minimum :
Seules les sorties du script seront affich√©es :
    option ¬´¬†-silent ¬ª.
 
	
‚Ä¢ et une proc√©dure :
	execute [|<nomPackage>.]<nomProc>

‚Ä¢ les blocs de code doivent SE TERMINER PAR UN SLASH pour √™tre ex√©cut√©s :
si une d√©claration de proc√©dure, package, ... ne se termine pas par un slash,
 sqlplus affichera un prompt d√©butant par un n¬∞ de ligne en attendant + de code.
Par contre, il ne faut PAS mettre de slash dans un bloc imbriqu√©.


‚Ä¢ VARIABLES SYST√àME NOTABLES :
_ set feedback off
	pas de messages de confirmation ou de nombre de colonnes en sortie.

_ set page[size] ùëõ
	si == 0, supprime les ent√™tes, titres & autres infos de formatage. 

_ set lin[|esize] <largeur> 
	largeur d'affichage des r√©sultats

_ set serveroutput on
	activer l'affichage des sorties DBMS

_ pour de l'export CSV :
	-- pas d'√©criture sur la sortie standard
	set termout off
	-- pas de messages de confirmation
	set feedback off
	-- pas d'ent√™tes
	set headsep off
	set pagesize 0
	-- s√©parateur de colonnes
	set colsep ","
	--pas de conversions des espaces en tabulations
	set tab off
	-- pas de retour √† la ligne
	set wrap off
	--
	-- utiliser la cha√Æne ¬´ NULL ¬ª pour les valeurs nulles
	set null "NULL"
	-- √©vite de combler les lignes par des blancs
	set trimspool on
	set trimout on
	-- arme la largeur de ligne
	set linesize 256
	-- nombre de chiffres par colonne num√©rique
	set numwidth 2



‚Ä¢ D√âFINIR UNE ¬´ VARIABLE DE SUBSTITUTION ¬ª SQLPLUS :
variable de substitution <> variable li√©e (¬´ bound variables ¬ª) :
	_ contient du texte
	_ inconnue du SQL
	_ variable simplement remplac√©e par son contenu avant ex√©cution,
		doit √™tre quot√©e si elle contient une cha√Æne
	_ pr√©fix√©e par une esperluette
	_ prompt utilisateur si ind√©finie
	
	def[ine] var = val;
	//l'utilisation de la variable se fait via le pr√©fixe & :
	... &var ...
	
	
‚Ä¢ D√âFINIR UNE VARIABLE LI√âE (¬´ BOUND VARIABLE ¬ª) SQL :
	_ typ√©e
	_ acc√©d√©e par le SQL (lue et modifi√©e)
	_ pas besoin de quotes, vrai variable
	_ pr√©fix√©e par un deux-points
	_ pas de prompt

	VARIABLE var : type;
	//utilis√©e via un deux-points :
	... :var ...


‚Ä¢ ATTENTION AUX ESPERLUETTES / ¬´&¬ª :
**M√äME DANS LES COMMENTAIRES**, une esperluette sera interpr√©t√©e comme
 une r√©f√©rence √† une variable d√©finie par le mot suivant le ¬´&¬ª.
**Si cette pr√©tendue variable n'a pas √©t√© d√©finie**, elle provoquera l'affichage
 d'un prompt et la lecture de donn√©es depuis stdIn !
_ contournable par la commande ¬´ set scan off ¬ª


‚Ä¢ UTILISER LE RESULTAT D'UN SELECT COMME CODE DE RETOUR DE SQLPLUS :
d√©clarer une variable li√©e / SELECT INTO / ¬´ EXIT :variable ¬ª.
**NOTER L'UTILISATION DES DEUX-POINTS POUR TOUTES R√âF√âRENCES √Ä LA VARIABLE**

	VARIABLE nomVariable;
	BEGIN
		SELECT ... INTO :nomVariable;
	END;
	/
	EXIT :nomVariable.



‚óè La BdD est pleine, elle occupe toute la partition ? :
Pourquoi ne pas vider les tablespaces UNDO et TEMP, qui occupent parfois
des dizaines de Go ?
_ cr√©er & utiliser un nouveau tablespace TEMP2 bidon pour remplacer le pr√©c√©dent,
_ red√©marrer la base
_ abandonner le tablespace original, en r√©cr√©er un 3e lui √©tant indentique
_ red√©marrer ...
_ abandonner le tablespace TEMP2
‚Üí exemple :

-- cr√©er un nouveau tablespace et l'utiliser
--
CREATE TEMPORARY TABLESPACE TEMP2 TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0101.dbf' SIZE 20M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 32767M;
ALTER DATABASE DEFAULT TEMPORARY TABLESPACE TEMP2;

-- red√©marrer pour appliquer le changement  
shutdown immediate;
startup;

-- abandonner l'ancien tablespace
DROP TABLESPACE TEMP INCLUDING CONTENTS AND DATAFILES;

-- recr√©er un nouveau tablespace identique √† l'ancien, et l'utiliser ‚Äì mais vide
--
CREATE TEMPORARY TABLESPACE TEMP TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0102.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 32767M;
ALTER TABLESPACE TEMP ADD TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0103.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 8000M;
ALTER TABLESPACE TEMP ADD TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0104.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 11000M;
ALTER DATABASE DEFAULT TEMPORARY TABLESPACE TEMP;

-- red√©marrer pour appliquer le changement ...
shutdown immediate;
startup;

-- supprimer la tablespace temporaire
DROP TABLESPACE TEMP2 INCLUDING CONTENTS AND DATAFILES;





‚óè IMPORTER UN DUMP :
	impdp <utilisateur>/<MdP>@<h√¥te> directory=<dump_dir> dumpfile=<dump.dmp> \
		[logfile=<log.log>] schemas=CREMA,CREMA_LEC,CREMA_EAI \
		[|TABLE_EXISTS_ACTION=REPLACE]
		[|FULL]
		[|PARALLEL=ùëõ]
o√π
 <dump_dir> est le dossier contenant le dump √† importer,
 <dump.dmp> le fichier .dmp pr√©sent dans ce dossier
 <logfile> le fichier de log dans lequel on journalisera.
TABLE_EXISTS_ACTION=REPLACE :
	permet de remplacer les tables d√©j√† existantes
	(l'action par d√©faut est de les conserver)
FULL :
	import de TOUTE la DB, pas seulement des sch√©mas
PARALLEL=ùëõ :
	nombre de threads autoris√©s. 2x le nombre de c≈ìurs conseill√©.


‚óè SCHEMA :
correspond √† un utilisateur.



‚óè TABLESPACES :
Chaque tablespace correspond √† un ou plusieurs fichiers,
_ contenant des ¬´ extends ¬ª,
 blocs de donn√©es de m√™me nature stock√©s dans le fichier, li√©s par des pointeurs,
 optimisable pour diff√©rents utilisations :
‚Üí on placera √† la cr√©ation les tables ou index dans diff√©rents tablespaces en f¬∞ des besoins.

_¬†en g√©n√©ral, 1 tablespace pour les index, 1 autre pour les donn√©es.

_¬†create tablespace tbs_data
    datafile '/opt/oracle/oradata/PLSQLUTF8/data.dbf'
    size                                  10M;

‚Ä¢ lister les tablespaces :
	SELECT TABLESPACE_NAME, BLOCK_SIZE, STATUS, CONTENTS, EXTENT_MANAGEMENT, ALLOCATION_TYPE, SEGMENT_SPACE_MANAGEMENT FROM DBA_TABLESPACES ORDER BY TABLESPACE_NAME;



‚óè PLUGGABLE DATABASES (PDB) et CONTAINER DATABASES (CDB):
Une CDB contient 0 √† ùëõ PDB.
le CONTENEUR COURANT courant peut √™tre la racine du CDB ou un PDB.

‚Ä¢ cr√©er une nouvelle PDB de novo :
	CREATE PLUGGABLE DATABASE <nomPDB>
		ADMIN USER <adminUser> IDENTIFIED BY <MdP>
		FILE_NAME_CONVERT = ('/opt/oracle/oradata/<nomDB>/pdbseed/',
							 '/opt/oracle/oradata/<nomDB>/<nomPDB>/');
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN; # autoriser les acc√®s

‚Ä¢ cr√©er une PDB √† partir d'une PDB existante :
	CREATE PLUGGABLE DATABASE <nouvellePDB> FROM <ancPDB> \
		FILE_NAME_CONVERT = (
			'/opt/oracle/oradata/<dossierCDB>/<ancPDB>/',
			'/opt/oracle/oradata/<dossierCDB>/<nouvPDB>/'
		);

‚Ä¢ lister les CDB :
seul moyen connu :
	ls /opt/oracle/oradata/<nomDB>/
‚Üí ce seront les dossiers.

‚Ä¢ afficher conteneur courant :
	SHOW CON_NAME;

‚Ä¢ lister les PDB du conteneur courant :
	SELECT PDB_NAME, STATUS FROM DBA_PDBS;
ou
	SELECT NAME, CON_ID FROM v$active_services ORDER BY NAME;

‚Ä¢ basculer de PDB :
	ALTER PLUGGABLE DATABASE <nomPDBcourante> CLOSE;
	ALTER SESSION SET CONTAINER = <nomPDB>;
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN;

‚Ä¢ SE CONNECTER √Ä UN PDB DEPUIS UN CLIENT :
Utiliser le nom du SERVICE h√©bergeant la PDB, r√©cup√©r√© via
	¬´ lsnrctl service ¬ª
et sp√©cifier le nom d'h√¥te dans l'URI :
	sqlplus <user>[|/<MdP>]@//<h√¥te[|<port>]>/<service>
p.ex :
	sqlplus SYSTEM/MotDePasse@//localhost/d12utf8pdb_3_4_1_20190129_0630



‚óè CREATE :
‚Ä¢ cr√©er un utilisateur commun √† tous PDB :
	prefix√© par [cC]##

Peut se connecter √† toute PDB.
doit √™tre cr√©√© depuis le CDB racine.
	CREATE USER c##<user> CONTAINER=ALL;

‚Ä¢ cr√©er un index :
	CREATE INDEX nomIndex ON tableCible(col[|, col]*) [| TABLESPACE nomTBS];

‚Ä¢ cr√©er une s√©quence :
	CREATE SEQUENCE [|START WITH ùëõ] [|MINVALUE ùëõ] [|MAXVALUE ùëõ] [| [| INCREMENT BY ùëõ]

‚Ä¢ cr√©er une table √† partir de donn√©es d'une autre table :
Rapide. les blocs de donn√©es ne sont pas copi√©s, juste r√©f√©renc√©s en C.O.W.
	CREATE TABLE ... AS ( SELECT * FROM ...);



‚óè DROP :
‚Ä¢ utilisateur :
	DROP USER <utilisateur> CASCADE;
‚Ä¢ objet tel que table, index :
	DROP TABLE <table> [|PURGE];
	DROP INDEX <index>;

_ DROP TABLE <tbl> ‚Üí table mise dans la ¬´ recycle bin ¬ª et donc r√©cup√©rable 
_ DROP TABLE <tbl> ‚Üí table d√©finitivement perdue

‚â† TRUNCATE TABLE (ne vide que les donn√©es),
‚â† PURGE TABLESPACE <table>;

‚Ä¢ PDB :
il faut d'abord clore et d√©brancher la PDB du CDB avant de la supprimer :
	ALTER PLUGGABLE DATABASE <PDB> CLOSE;
	ALTER PLUGGABLE DATABASE <PDB> UNPLUG INTO 'xxx.xml'; 
	DROP PLUGGABLE DATABASE <PDB> [|INCLUDING DATAFILES];

‚Ä¢ espace de tables :
	DROP TABLESPACE <espaceDeTables> [INCLUDING CONTENTS [AND DATAFILES] [CASCADE CONSTRAINTS]];



‚óè TABLES NOTABLES :
_ all_tab_columns		tout les noms de colonnes
	select table_name from all_tab_columns where column_name='xxx';
_ DBA_PDBS				vue listant toutes les PluggableDataBase
_ DBA_USERS

‚Ä¢ DUAL :
Sous oracle, le FROM du SELECT est obligatoire.
DUAL permet d'exprimer le fait qu'on ne s√©lecte d'aucune table.
‚Üí SELECT 'const' (MySQL) == SELECT 'const' FROM DUAL ...

select sysdate from dual;



‚óè S√âLECTIONNER DES LIGNES D'UNE LISTE :
    SELECT COLUMN_VALUE FROM TABLE(sys.odcinumberList(...))



‚óè FAITS NOTABLES DU SQL ORACLE :
¬´ uncommited ¬ª par d√©faut.

‚Ä¢ limiter le nombre de lignes du r√©sultat :
WHERE ROWNUM < ùëõ

OFFSET premLn ROWS FETCH NEXT nbLn ROWS ONLY;

FETCH FIRST num% PERCENT ROWS ONLY;



‚óè RECHERCHER UNE COLONNE, CONTRAINTE, OU INDEX :
‚Ä¢ trouver une contrainte de CLEF PRIMAIRE :
	SELECT * FROM [USER_CONSTRAINTS|ALL_CONSTRAINTS|DBA_CONSTRAINTS]
	WHERE
		CONSTRAINT_NAME = '...'
	  AND
		CONSTRAINT_TYPE = 'P'
	  AND
		TABLE_NAME = '...' ;
¬† USER_CONSTRAINTS :
    contraintes poss√©d√©es par l'utilisateur
  ALL_CONSTRAINTS : 
    constraints visibles par l'utilisateur
  DBA_CONSTRAINTS :
    toutes les contraintes

‚Ä¢ trouver les clefs √©trang√®res pointant ves une table :
    SELECT *
    FROM ALL_CONSTRAINTS
    WHERE
        r_constraint_name IN (
          select constraint_name
          FROM all_constraints
          WHERE
            table_name = 'DIA_TABLEAU_BORD'
        );
la sous-requ√™te retourne les noms des contraintes, mais pas les tables d'origine,
la requ√™te globale indique table faisant r√©f√©rence √† la table indiqu√©e.

 

‚Ä¢ trouver un index :
	SELECT * FROM USER_INDEXES
	WHERE 
		TABLE_NAME = '...';
‚Ä¢ trouver les index sur telle colonne :
	SELECT * FROM ALL_IND_COLUMNS WHERE COLUMN_NAME = '...'; 

‚Ä¢ trouver une COLONNE :
	SELECT * FROM ALL_TAB_COLUMNS
	WHERE COLUMN_NAME = '...';



‚Ä¢ CHANGER LE SCH√âMA ACTUEL :
	ALTER SESSION SET CURRENT_SCHEMA = <nomSch√©maSansGuillemets>;



‚óè S√âQUENCES :
‚Ä¢ lire la derni√®re valeur :
	SELECT <nomSEQ>.nextVal FROM DUAL;

‚Ä¢ lister les s√©quences :
	SELECT * FROM ALL_SEQUENCES;

‚Ä¢ options de cr√©ation utiles (non exhaustif !) :
	CREATE SEQUENCE [|START WITH ùëõ]
		[|MINVALUE ùëõ] [|MAXVALUE ùëõ]
		[|INCREMENT BY ùëõ]
		[|CACHE ùëõ|NOCACHE]	# CACHE : met en cache en m√©moire les ùëõ prochaines valeurs. 
							# 		valeurs perdues en cache de panne ou autre.

‚Ä¢ r√©armer la valeur : 
le plus simple est de d√©truire & recr√©er la s√©quence ...

‚óè TYPES ORACLE ‚Äì cha√Ænes :
attention √† l'encocage des caract√®res, pr√©voir assez de place.

_ CHAR(lng)
	longueur fixe (1 par d√©faut, jusque 32Ko)

_ VARCHAR2(lng [|BYTE|CHAR])
    longueur variable, valeur stock√©e s√©par√©ment de la table y faisant r√©f√©rence.
	taille maximale (d√©faut) : 4000 o.
	taille maximale configurable  :
	    jusqu'√† 32767 o, configurable par le param√®tre MAX_STRING_SIZE. 

SELECT LENGTH('√âLECTRICIT√â'), LENGTHB('√âLECTRICIT√â') FROM DUAL
	‚Üí 11 CHAR, 13 BYTES

‚óè TYPES ‚Äì timezone :
‚Ä¢ timezone de la connexion, de la base de donn√©es, et du serveur h√©bergeant cette derni√®re. 

‚óè TYPES ‚Äì date :
‚Ä¢ ATTENTION, oracle stocke les millisecondes par d√©faut.
_ TIMESTAMP
_ TIMESTAMP WITH TIME ZONE
_ TIMESTAMP WITH LOCAL TIMEZONE




‚óè ENCODAGE :
‚Ä¢ les plus courants : 
	WE8MSWIN1252
	AL32UTF8
‚Ä¢ d√©finit au niveau de la BdD, et de la colonne.



‚óè FONCTIONS :
_ NVL(v1, v2) : renvoit v2 si v1 == NULL

_ OP√âRATEUR ¬´q¬ª : permet de d√©finir un caract√®re d'encadrement alternatif pour remplacer les guillemets :
	q'!a'b'c!' ‚Üí le contenu de la cha√Æne est d√©limit√© par !


‚óè DATES ‚Äì FONCTIONS :
‚Ä¢ utiliser ¬´ TO_DATE( <date>, <format>) ¬ª :
bonne pratique pour se rendre ind√©pendant du format de date par d√©faut.
p.ex,
	TO_DATE('14/10/2010', 'DD/MM/YYYY')

‚Ä¢ EXTRACT(Date, <unit√©>) :
_ EXTRACT() renvoit le champs demand√© :
	EXTRACT(&date, [SECOND|MINUTE|HOUR|DATE|WEEK|MONTH|DAY_OF_WEEK|DAY_OF_MONTH|...])

‚Ä¢ TRUNC(Date, <format>) :
TRUNC() renvoit une DATE (quelque soit le format de date d'entr√©e) TRONQU√âE
suivant l'unit√©e sp√©cifi√©e par <format> :
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'MONTH' )	==	01/10/2010
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'YEAR' )	==	01/01/2010
‚Ä¢ TRUNC(Date) :
	par d√©faut, si le format est omis, TRUNC() arrondi au jour.

‚Ä¢ calcul de dates :
	<date> + ùëõ
	<date> - ùëõ		‚Üí ajoute ou soustrait ùëõ jours √† la date donn√©e.
						fonctionne pour les DATE mais PAS pour les TIMESTAMP.

	LAST_DAY(date) ‚Üí arme la date au dernier jour du mois contenu

_ op√©rations avec les ¬´INTERVAL¬ª :
	uneDate + INTERVAL 'nb' [YEAR|MONTH|DAY|HOUR|MINUTE];
p.ex 
	table.colonneDate + INTERVAL '5' DAY


‚Ä¢ afficher composants d'une date ou timestamp :
	TO_CHAR( <date>, <format> )
p.ex
	TO_CHAR(colDate, 'HH24:MI')	//heure & minutes (format 24h)
	TO_CHAR(colDate, 'DD/MM/IYYY') // n¬∞jour/n¬∞mois/ann√©e s/ 4 chiffres
pour le format, cf
	https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements004.htm#i34510

‚Ä¢ SYSDATE ‚â† CURRENT_DATE :
_ SYSDATE :
	date courante sur le SERVEUR. Retour d√©pendant de NLS_DATE_FORMAT.
_ CURRENT_DATE :
	donn√©es dans la zone de temps de la SESSION



‚óè GROUP BY / ORDER BY :
‚Ä¢ optimisation possible :
Utiliser une sous-requ√™te contenant le GROUP BY, trier dans la requ√™te principale :

	-- ‚Ä¢ combien de courbes √† remonter chaque semaine ?
	SELECT TRUNC(DATE_COURBE, 'MONTH') Mois, COUNT(COURBE_ID) "nb courbes"
	FROM DIA_COURBES
	WHERE
	  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
	  AND EST_DERNIERE_VERSION = 1
	  AND PUBLIABLE = 1
	GROUP BY TRUNC(DATE_COURBE, 'MONTH')
	ORDER BY TRUNC(DATE_COURBE, 'MONTH') DESC;
devient :
	WITH unsorted as (
		SELECT
		  TRUNC(DATE_COURBE, 'MONTH') Mois,
		  COUNT(COURBE_ID)            "nb courbes"
		FROM DIA_COURBES
		WHERE
		  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
		  AND EST_DERNIERE_VERSION = 1
		  AND PUBLIABLE = 1
		group by TRUNC(DATE_COURBE, 'MONTH')
	)
	select *
	from unsorted
	ORDER BY Mois DESC;



‚óè TRIGGERS :
	CREATE OR REPLACE TRIGGER <TODO>

