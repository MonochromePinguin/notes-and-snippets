‚óè commandes en ln-d-comm :
‚Ä¢ lister les services accessibles :
	lsnrctl service
¬ø¬ø¬ø apparemment, il existe un service pour chaque PDB ... ???


‚óè LA BDD NE R√âPONDS PAS AU D√âMARRAGE
 ¬´ ERROR : ORA-01033: ORACLE initialization or shutdown in progress ¬ª :
La BdD doit √™tre r√©-ouverte. (¬øpourquoi?)
Ce qui a march√© sous ¬´ sqlplus / as sysdba ¬ª :

_ DERNI√àRE VERSION :
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_2_20181210 OPEN READ WRITE;

_ ANCIENNE VERSION :
	SHUTDOWN IMMEDIATE			# red√©marrer la BdD : ¬ø utile ?
	STARTUP						# ¬ø?
	ALTER SESSION SET CONTAINER = D12UTF8PDB_3_4_1_20181226_516;
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_1_20181226_516 open; ## ¬ø peut-√™tre la seule ligne utile ?



‚óè SQLPLUS :
‚Ä¢ connexion :
sqlplus						‚Üí	√† la BdD par d√©faut
sqlplus <NOM>@<BdD>
sqlplus <NOM>/<MdP>@<BdD>	moins s√©curis√©


‚Ä¢ ex√©cuter un script :
	@<fichier>
‚Ä¢ et une proc√©dure :
	execute [|<nomPackage>.]<nomProc>

‚Ä¢ les blocs de code doivent SE TERMINER PAR UN SLASH pour √™tre ex√©cut√©s :
si une d√©claration de proc√©dure, package, ... ne se termine pas par un slash,
 sqlplus affichera un prompt d√©butant par un n¬∞ de ligne en attendant + de code.


‚Ä¢ largeur d'affichage des r√©sultats :
	set lin[|esize] <largeur> 

‚Ä¢ d√©finir une variable :
	def var = val
ou
	define var = val
	//l'utilisation de la variable se fait via le pr√©fixe & :
	... &var ...

‚Ä¢ ATTENTION AUX ESPERLUETTES / ¬´&¬ª :
**M√™me dans les commentaires**, une esperluette sera interpr√©t√©e comme
 une r√©f√©rence √† une variable d√©finie par le mot suivant le ¬´&¬ª.
**Si cette pr√©tendue variable n'a pas √©t√© d√©finie**, elle provoquera l'affichage
 d'un prompt et la lecture de donn√©es depuis stdIn !
_ contournable par la commande ¬´ set scan off ¬ª


‚Ä¢ activer l'affichage des sorties DBMS :
set serveroutput on;


‚óè La BdD est pleine, elle occupe toute la partition ? :
Pourquoi ne pas vider les tablespaces UNDO et TEMP, qui occupent parfois
des dizaines de Go ?
_ cr√©er un nouveau tablespace TEMP pour remplacer le pr√©c√©dent,
_ red√©marrer la base ‚Äì ce qui va
‚Üí exemple :

-- cr√©er un nouveau tablespace et l'utiliser
--
CREATE TEMPORARY TABLESPACE TEMP2 TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0101.dbf' SIZE 20M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 32767M;
ALTER DATABASE DEFAULT TEMPORARY TABLESPACE TEMP2;

-- red√©marrer pour appliquer le changement  
shutdown immediate;
startup;

-- abandonner l'ancien tablespace
DROP TABLESPACE TEMP INCLUDING CONTENTS AND DATAFILES;

-- recr√©er un nouveau tablespace identique √† l'ancien, et l'utiliser ‚Äì mais vide
--
CREATE TEMPORARY TABLESPACE TEMP TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0102.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 32767M;
ALTER TABLESPACE TEMP ADD TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0103.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 8000M;
ALTER TABLESPACE TEMP ADD TEMPFILE '/opt/oracle/oradata/RTE12UTF8/datafile/temp0104.dbf' SIZE 25M REUSE AUTOEXTEND ON NEXT 1280K MAXSIZE 11000M;
ALTER DATABASE DEFAULT TEMPORARY TABLESPACE TEMP;

-- red√©marrer pour appliquer le changement ...
shutdown immediate;
startup;

-- supprimer la tablespace temporaire
DROP TABLESPACE TEMP2 INCLUDING CONTENTS AND DATAFILES;





‚óè IMPORTER UN DUMP :
	impdp <utilisateur>/<MdP>@<h√¥te> directory=<dump_dir> dumpfile=<dump.dmp> \
		[logfile=<log.log>] schemas=CREMA,CREMA_LEC,CREMA_EAI \
		[|TABLE_EXISTS_ACTION=REPLACE]
		[|FULL]
		[|PARALLEL=ùëõ]
o√π
 <dump_dir> est le dossier contenant le dump √† importer,
 <dump.dmp> le fichier .dmp pr√©sent dans ce dossier
 <logfile> le fichier de log dans lequel on journalisera.
TABLE_EXISTS_ACTION=REPLACE :
	permet de remplacer les tables d√©j√† existantes
	(l'action par d√©faut est de les conserver)
FULL :
	import de TOUTE la DB, pas seulement des sch√©mas
PARALLEL=ùëõ :
	nombre de threads autoris√©s. 2x le nombre de c≈ìurs conseill√©.


‚óè SCHEMA :
correspond √† un utilisateur.



‚óè TABLESPACES :
Chaque tablespace correspond √† un ou plusieurs fichiers,
_ contenant des ¬´ extends ¬ª,
 blocs de donn√©es de m√™me nature stock√©s dans le fichier, li√©s par des pointeurs,
 optimisable pour diff√©rents utilisations :
‚Üí on placera √† la cr√©ation les tables ou index dans diff√©rents tablespaces en f¬∞ des besoins.

_¬†en g√©n√©ral, 1 tablespace pour les index, 1 autre pour les donn√©es.

_¬†create tablespace tbs_data
    datafile '/opt/oracle/oradata/PLSQLUTF8/data.dbf'
    size                                  10M;

‚Ä¢ lister les tablespaces :
	SELECT TABLESPACE_NAME, BLOCK_SIZE, STATUS, CONTENTS, EXTENT_MANAGEMENT, ALLOCATION_TYPE, SEGMENT_SPACE_MANAGEMENT FROM DBA_TABLESPACES ORDER BY TABLESPACE_NAME;



‚óè PLUGGABLE DATABASES (PDB) et CONTAINER DATABASES (CDB):
Une CDB contient 0 √† ùëõ PDB.
le CONTENEUR COURANT courant peut √™tre la racine du CDB ou un PDB.

‚Ä¢ cr√©er une nouvelle PDB de novo :
	CREATE PLUGGABLE DATABASE <nomPDB>
		ADMIN USER <adminUser> IDENTIFIED BY <MdP>
		FILE_NAME_CONVERT = ('/opt/oracle/oradata/<nomDB>/pdbseed/',
							 '/opt/oracle/oradata/<nomDB>/<nomPDB>/');
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN; # autoriser les acc√®s

‚Ä¢ cr√©er une PDB √† partir d'une PDB existante :
	CREATE PLUGGABLE DATABASE <nouvellePDB> FROM <ancPDB> \
		FILE_NAME_CONVERT = (
			'/opt/oracle/oradata/<dossierCDB>/<ancPDB>/',
			'/opt/oracle/oradata/<dossierCDB>/<nouvPDB>/'
		);

‚Ä¢ lister les CDB :
seul moyen connu :
	ls /opt/oracle/oradata/<nomDB>/
‚Üí ce seront les dossiers.

‚Ä¢ afficher conteneur courant :
	SHOW CON_NAME;

‚Ä¢ lister les PDB du conteneur courant :
	SELECT PDB_NAME, STATUS FROM DBA_PDBS;
ou
	SELECT NAME, CON_ID FROM v$active_services ORDER BY NAME;

‚Ä¢ basculer de PDB :
	ALTER PLUGGABLE DATABASE <nomPDBcourante> CLOSE;
	ALTER SESSION SET CONTAINER = <nomPDB>;
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN;

‚Ä¢ SE CONNECTER √Ä UN PDB DEPUIS UN CLIENT :
Utiliser le nom du SERVICE h√©bergeant la PDB, r√©cup√©r√© via
	¬´ lsnrctl service ¬ª
et sp√©cifier le nom d'h√¥te dans l'URI :
	sqlplus <user>[|/<MdP>]@//<h√¥te[|<port>]>/<service>
p.ex :
	sqlplus SYSTEM/MotDePasse@//localhost/d12utf8pdb_3_4_1_20190129_0630

‚óè CREATE :
‚Ä¢ cr√©er un utilisateur commun √† tous PDB :
	prefix√© par [cC]##

Peut se connecter √† toute PDB.
doit √™tre cr√©√© depuis le CDB racine.
	CREATE USER c##<user> CONTAINER=ALL;

‚Ä¢ cr√©er un index :
	CREATE INDEX nomIndex ON tableCible(col[|, col]*) [| TABLESPACE nomTBS];

‚Ä¢ cr√©er une s√©quence :
	CREATE SEQUENCE [|START WITH ùëõ] [|MINVALUE ùëõ] [|MAXVALUE ùëõ] [| [| INCREMENT BY ùëõ]

‚Ä¢ cr√©er une table √† partir de donn√©es :
	CREATE TABLE ... AS ( SELECT * FROM ...);


‚óè DROP :
‚Ä¢ utilisateur :
	DROP USER <utilisateur> CASCADE;
‚Ä¢ objet tel que table, index :
	DROP TABLE <table> [|PURGE];
	DROP INDEX <index>;

_ DROP TABLE <tbl> ‚Üí table mise dans la ¬´ recycle bin ¬ª et donc r√©cup√©rable 
_ DROP TABLE <tbl> ‚Üí table d√©finitivement perdue

‚â† TRUNCATE TABLE (ne vide que les donn√©es),
‚â† PURGE TABLESPACE <table>;

‚Ä¢ PDB :
il faut d'abord clore et d√©brancher la PDB du CDB avant de la supprimer :
	ALTER PLUGGABLE DATABASE <PDB> CLOSE;
	ALTER PLUGGABLE DATABASE <PDB> UNPLUG INTO 'xxx.xml'; 
	DROP PLUGGABLE DATABASE <PDB> [|INCLUDING DATAFILES];

‚Ä¢ espace de tables :
	DROP TABLESPACE <espaceDeTables> [INCLUDING CONTENTS [AND DATAFILES] [CASCADE CONSTRAINTS]];



‚óè TABLES NOTABLES :
_ all_tab_columns		tout les noms de colonnes
	select table_name from all_tab_columns where column_name='xxx';
_ DBA_PDBS				vue listant toutes les PluggableDataBase
_ DBA_USERS

‚Ä¢ DUAL :
Sous oracle, le FROM du SELECT est obligatoire.
DUAL permet d'exprimer le fait qu'on ne s√©lecte d'aucune table.
‚Üí SELECT 'const' (MySQL) == SELECT 'const' FROM DUAL ...

select sysdate from dual;


‚óè FAITS NOTABLES DU SQL ORACLE :
¬´ uncommited ¬ª par d√©faut.

‚Ä¢ limiter le nombre de lignes du r√©sultat :
WHERE ROWNUM < ùëõ

OFFSET premLn ROWS FETCH NEXT nbLn ROWS ONLY;

FETCH FIRST num% PERCENT ROWS ONLY;



‚óè RECHERCHER UNE COLONNE, CONTRAINTE, OU INDEX :
‚Ä¢ trouver une contrainte de CLEF PRIMAIRE :
	SELECT * FROM [USER_CONSTRAINTS|ALL_CONSTRAINTS|DBA_CONSTRAINTS]
	WHERE
		CONSTRAINT_NAME = '...'
	  AND
		CONSTRAINT_TYPE = 'P'
	  AND
		TABLE_NAME = '...' ;
¬† USER_CONSTRAINTS :
    contraintes poss√©d√©es par l'utilisateur
  ALL_CONSTRAINTS : 
    constraints visibles par l'utilisateur
  DBA_CONSTRAINTS :
    toutes les contraintes

‚Ä¢ trouver un index :
	SELECT * FROM USER_INDEXES
	WHERE 
		TABLE_NAME = '...';
‚Ä¢ trouver les index sur telle colonne :
	SELECT * FROM ALL_IND_COLUMNS WHERE COLUMN_NAME = '...'; 

‚Ä¢ trouver une COLONNE :
	SELECT * FROM ALL_TAB_COLUMNS
	WHERE COLUMN_NAME = '...';



‚Ä¢ CHANGER LE SCH√âMA ACTUEL :
	ALTER SESSION SET CURRENT_SCHEMA = <nomSch√©maSansGuillemets>;



‚óè S√âQUENCES :
‚Ä¢ lire la derni√®re valeur :
	SELECT <nomSEQ>.nextVal FROM DUAL;

‚Ä¢ lister les s√©quences :
	SELECT * FROM ALL_SEQUENCES;

‚Ä¢ options de cr√©ation utiles (non exhaustif !) :
	CREATE SEQUENCE [|START WITH ùëõ]
		[|MINVALUE ùëõ] [|MAXVALUE ùëõ]
		[|INCREMENT BY ùëõ]
		[|CACHE ùëõ|NOCACHE]	# CACHE : met en cache en m√©moire les ùëõ prochaines valeurs. 
							# 		valeurs perdues en cache de panne ou autre.

‚Ä¢ r√©armer la valeur : 
le plus simple est de d√©truire & recr√©er la s√©quence ...

‚óè TYPES ORACLE ‚Äì cha√Ænes :
attention √† l'encocage des caract√®res, pr√©voir assez de place.

_ CHAR(lng)
	longueur fixe (1 par d√©faut, jusque 32Ko)

_ VARCHAR2(lng [|BYTE|CHAR])
	longueur variable, valeur stock√©e s√©par√©mment de la table y faisant r√©f√©rence.

SELECT LENGTH('√âLECTRICIT√â'), LENGTHB('√âLECTRICIT√â') FROM DUAL
	‚Üí 11 CHAR, 13 BYTES

‚óè TYPES ‚Äì timezone :
‚Ä¢ timezone de la connexion, de la base de donn√©es, et du serveur h√©bergeant cette derni√®re. 

‚óè TYPES ‚Äì date :
‚Ä¢ ATTENTION, oracle stocke par d√©faut les millisecondes.
_ TIMESTAMP
_ TIMESTAMP WITH TIME ZONE
_ TIMESTAMP WITH LOCAL TIMEZONE

_DATE : chez oracle, stocke date et heure.
**PAR D√âFAUT, UN SELECT NE RENVOIT QUE LA PARTIE ¬´DATE¬ª**
‚Ä¢ Pour requ√™ter une date avec heure:minutes:secondes :
	TO_CHAR(DATE_DERNIERE_EXEC, 'YYYY-MM-DD HH24:MI:SS')
ou **sans les secondes** :
	TRUNC(DATE_DERNIERE_EXEC, 'MI')
car la granularit√© de DATE est √† la seconde, pas de 'SS' pour TRUNC() 


‚óè ENCODAGE :
‚Ä¢ les plus courants : 
	WE8MSWIN1252
	AL32UTF8
‚Ä¢ d√©finit au niveau de la BdD, et de la colonne.


‚óè FONCTIONS :
_ NVL(v1, v2) : renvoit v2 si v1 == NULL

_ OP√âRATEUR ¬´q¬ª : permet de d√©finir un caract√®re d'encadrement alternatif pour remplacer les guillemets :
	q'!a'b'c!' ‚Üí le contenu de la cha√Æne est d√©limit√© par !


‚óè DATES ‚Äì FONCTIONS :
‚Ä¢ utiliser ¬´ TO_DATE( <date>, <format>) ¬ª :
bonne pratique pour se rendre ind√©pendant du format de date par d√©faut.
p.ex,
	TO_DATE('14/10/2010', 'DD/MM/YYYY')

‚Ä¢ EXTRACT(Date, <unit√©>) :
_ EXTRACT() renvoit le champs demand√© :
	EXTRACT(&date, [SECOND|MINUTE|HOUR|DATE|WEEK|MONTH|DAY_OF_WEEK|DAY_OF_MONTH|...])

‚Ä¢ TRUNC(Date, <format>) :
TRUNC() renvoit une DATE (quelque soit le format de date d'entr√©e) TRONQU√âE
suivant l'unit√©e sp√©cifi√©e par <format> :
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'MONTH' )	==	01/10/2010
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'YEAR' )	==	01/01/2010


‚Ä¢ calcul de dates :
	<date> + ùëõ
	<date> - ùëõ		‚Üí ajoute ou soustrait ùëõ jours √† la date donn√©e.
						fonctionne pour les DATE mais PAS pour les TIMESTAMP.

	LAST_DAY(date) ‚Üí arme la date au dernier jour du mois contenu

_ op√©rations avec les ¬´INTERVAL¬ª :
	uneDate + INTERVAL 'nb' [YEAR|MONTH|DAY|HOUR|MINUTE];
p.ex 
	table.colonneDate + INTERVAL '5' DAY


‚Ä¢ afficher composants d'une date ou timestamp :
	TO_CHAR( <date>, <format> )
p.ex
	TO_CHAR(colDate, 'HH24:MI')	//heure & minutes (format 24h)
	TO_CHAR(colDate, 'DD/MM/IYYY') // n¬∞jour/n¬∞mois/ann√©e s/ 4 chiffres
pour le format, cf
	https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements004.htm#i34510

‚Ä¢ SYSDATE ‚â† CURRENT_DATE :
_ SYSDATE :
	date courante sur le SERVEUR. Retour d√©pendant de NLS_DATE_FORMAT.
_ CURRENT_DATE :
	donn√©es dans la zone de temps de la SESSION



‚óè GROUP BY / ORDER BY :
‚Ä¢ optimisation possible :
Utiliser une sous-requ√™te contenant le GROUP BY, trier dans la requ√™te principale :

	-- ‚Ä¢ combien de courbes √† remonter chaque semaine ?
	SELECT TRUNC(DATE_COURBE, 'MONTH') Mois, COUNT(COURBE_ID) "nb courbes"
	FROM DIA_COURBES
	WHERE
	  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
	  AND EST_DERNIERE_VERSION = 1
	  AND PUBLIABLE = 1
	GROUP BY TRUNC(DATE_COURBE, 'MONTH')
	ORDER BY TRUNC(DATE_COURBE, 'MONTH') DESC;
devient :
	WITH unsorted as (
		SELECT
		  TRUNC(DATE_COURBE, 'MONTH') Mois,
		  COUNT(COURBE_ID)            "nb courbes"
		FROM DIA_COURBES
		WHERE
		  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
		  AND EST_DERNIERE_VERSION = 1
		  AND PUBLIABLE = 1
		group by TRUNC(DATE_COURBE, 'MONTH')
	)
	select *
	from unsorted
	ORDER BY Mois DESC;



‚óè TRIGGERS :
	CREATE OR REPLACE TRIGGER <TODO>

