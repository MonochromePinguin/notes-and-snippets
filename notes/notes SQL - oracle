‚óè commandes en ln-d-comm :
‚Ä¢ lister les services accessibles :
	lsnrctl service
¬ø¬ø¬ø apparemment, il existe un service pour chaque PDB ... ???


‚óè LA BDD NE R√âPONDS PAS AU D√âMARRAGE
 ¬´ ERROR : ORA-01033: ORACLE initialization or shutdown in progress ¬ª :
La BdD doit √™tre r√©-ouverte. (¬øpourquoi?)
Ce qui a march√© sous ¬´ sqlplus / as sysdba ¬ª :

_ DERNI√àRE VERSION :
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_2_20181210 OPEN READ WRITE;

_ ANCIENNE VERSION :
	SHUTDOWN IMMEDIATE			# red√©marrer la BdD : ¬ø utile ?
	STARTUP						# ¬ø?
	ALTER SESSION SET CONTAINER = D12UTF8PDB_3_4_1_20181226_516;
	ALTER PLUGGABLE DATABASE D12UTF8PDB_3_4_1_20181226_516 open; ## ¬ø peut-√™tre la seule ligne utile ?


‚óè IMPORTER UN DUMP :
	impdp <utilisateur>/<MdP>@<h√¥te> directory=<dump_dir> dumpfile=<dump.dmp> \
		[logfile=<log.log>] schemas=CREMA,CREMA_LEC,CREMA_EAI \
		[|TABLE_EXISTS_ACTION=REPLACE]
		[|FULL]
		[|PARALLEL=ùëõ]
o√π
 <dump_dir> est le dossier contenant le dump √† importer,
 <dump.dmp> le fichier .dmp pr√©sent dans ce dossier
 <logfile> le fichier de log dans lequel on journalisera.
TABLE_EXISTS_ACTION=REPLACE :
	permet de remplacer les tables d√©j√† existantes (l'action par d√©faut est de les conserver)
FULL :
	import de TOUTE la DB, pas seulement des sch√©mas
PARALLEL=ùëõ :
	nombre de threads autoris√©s. 2x le nombre de c≈ìurs conseill√©.


‚óè TABLESPACES :
 xxxxx <TODO> xxxxx
	SELECT TABLESPACE_NAME, BLOCK_SIZE, STATUS, CONTENTS, EXTENT_MANAGEMENT, ALLOCATION_TYPE, SEGMENT_SPACE_MANAGEMENT FROM DBA_TABLESPACES ORDER BY TABLESPACE_NAME;



‚óè PLUGGABLE DATABASES (PDB) et CONTAINER DATABASES (CDB):
Une CDB contient 0 √† ùëõ PDB.
le CONTENEUR COURANT courant peut √™tre la racine du CDB ou un PDB.

‚Ä¢ cr√©er une nouvelle PDB de novo :
	CREATE PLUGGABLE DATABASE <nomPDB>
		ADMIN USER <adminUser> IDENTIFIED BY <MdP>
		FILE_NAME_CONVERT = ('/opt/oracle/oradata/<nomDB>/pdbseed/',
							 '/opt/oracle/oradata/<nomDB>/<nomPDB>/');
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN; # autoriser les acc√®s

‚Ä¢ cr√©er une PDB √† partir d'une PDB existante :
	CREATE PLUGGABLE DATABASE <nouvellePDB> FROM <ancPDB> \
		FILE_NAME_CONVERT = (
			'/opt/oracle/oradata/<dossierCDB>/<ancPDB>/',
			'/opt/oracle/oradata/<dossierCDB>/<nouvPDB>/'
		);

‚Ä¢ lister les CDB :
seul moyen connu :
	ls /opt/oracle/oradata/<nomDB>/
‚Üí ce seront les dossiers.

‚Ä¢ afficher conteneur courant :
	SHOW CON_NAME;

‚Ä¢ lister les PDB du conteneur courant :
	SELECT PDB_NAME, STATUS FROM DBA_PDBS;
ou
	SELECT NAME, CON_ID FROM v$active_services ORDER BY NAME;

‚Ä¢ basculer de PDB :
	ALTER PLUGGABLE DATABASE <nomPDBcourante> CLOSE;
	ALTER SESSION SET CONTAINER = <nomPDB>;
	ALTER PLUGGABLE DATABASE <nomPDB> OPEN;

‚Ä¢ SE CONNECTER √Ä UN PDB DEPUIS UN CLIENT :
Utiliser le nom du SERVICE h√©bergeant la PDB, r√©cup√©r√© via
	¬´ lsnrctl service ¬ª
et sp√©cifier le nom d'h√¥te dans l'URI :
	sqlplus <user>[|/<MdP>]@//<h√¥te[|<port>]>/<service>
p.ex :
	sqlplus SYSTEM/MotDePasse@//localhost/d12utf8pdb_3_4_1_20190129_0630

‚óè CREATE USER :
‚Ä¢ utilisateur commun :
	prefix√© par [cC]##

Peut se connecter √† toute PDB.
doit √™tre cr√©√© depuis le CDB racine.
	CREATE USER c##<user> CONTAINER=ALL;


‚óè DROP :
‚Ä¢ utilisateur :
	DROP USER <utilisateur> CASCADE;
‚Ä¢ table :
	PURGE TABLESPACE <table>;

‚Ä¢ PDB :
il faut d'abord clore et d√©brancher la PDB du CDB avant de la supprimer :
	ALTER PLUGGABLE DATABASE <PDB> CLOSE;
	ALTER PLUGGABLE DATABASE <PDB> UNPLUG INTO 'xxx.xml'; 
	DROP PLUGGABLE DATABASE <PDB> [|INCLUDING DATAFILES];

‚Ä¢ espace de tables :
	DROP TABLESPACE <espaceDeTables> [INCLUDING CONTENTS [AND DATAFILES] [CASCADE CONSTRAINTS]];



‚óè TABLES NOTABLES :
_ all_tab_columns		tout les noms de colonnes
	select table_name from all_tab_columns where column_name='xxx';
_ DBA_PDBS				vue listant toutes les PluggableDataBase
_ DBA_USERS


‚óè FAITS NOTABLES DU SQL ORACLE :
¬´ uncommited ¬ª par d√©faut.

‚Ä¢ limiter le nombre de lignes du r√©sultat :
WHERE ROWNUM < ùëõ

OFFSET premLn ROWS FETCH NEXT nbLn ROWS ONLY;

FETCH FIRST num% PERCENT ROWS ONLY;



‚óè RECHERCHER UNE COLONNE, CONTRAINTE, OU INDEX :
‚Ä¢ trouver une contrainte de CLEF PRIMAIRE :
	SELECT * FROM [USER_CONSTRAINTS|ALL_CONSTRAINTS|DBA_CONSTRAINTS]
	WHERE
		CONSTRAINT_NAME = '...'
	  AND
		CONSTRAINT_TYPE = 'P'
	  AND
		TABLE_NAME = '...' ;
¬† USER_CONSTRAINTS :
    contraintes poss√©d√©es par l'utilisateur
  ALL_CONSTRAINTS : 
    constraints visibles par l'utilisateur
  DBA_CONSTRAINTS :
    toutes les contraintes

‚Ä¢ trouver un index :
	SELECT * FROM USER_INDEXES
	WHERE 
		TABLE_NAME = '...';
‚Ä¢ trouver les index sur telle colonne :
	SELECT * FROM ALL_IND_COLUMNS WHERE COLUMN_NAME = '...'; 

‚Ä¢ trouver une COLONNE :
	SELECT * FROM ALL_TAB_COLUMNS
	WHERE COLUMN_NAME = '...';



‚Ä¢ CHANGER LE SCH√âMA ACTUEL :
	ALTER SESSION SET CURRENT_SCHEMA = <nomSch√©maSansGuillemets>;



‚óè S√âQUENCES :
	SELECT * FROM ALL_SEQUENCES



‚óè DATES ‚Äì FONCTIONS :
‚Ä¢ utiliser ¬´ TO_DATE( <date>, <format>) ¬ª :
bonne pratique pour se rendre ind√©pendant du format de date par d√©faut.
p.ex,
	TO_DATE('14/10/2010', 'DD/MM/YYYY')

‚Ä¢ EXTRACT(Date, <unit√©>) :
_ EXTRACT() renvoit le champs demand√© :
	EXTRACT(&date, [SECOND|MINUTE|HOUR|DATE|WEEK|MONTH|DAY_OF_WEEK|DAY_OF_MONTH|...])

‚Ä¢ TRUNC(Date, <format>) :
TRUNC() renvoit une DATE (quelque soit le format de date d'entr√©e) TRONQU√âE
suivant l'unit√©e sp√©cifi√©e par <format> :
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'MONTH' )	==	01/10/2010
	TRUNC( TO_DATE('14/10/2010', 'DD/MM/YYYY'), 'YEAR' )	==	01/01/2010


‚Ä¢ calcul de dates :
	<date> - ùëõ		‚Üí soustrait ùëõ jours √† la date donn√©e.
						fonctionne pour les DATE mais pas les TIMESTAMP.

	LAST_DAY(date) ‚Üí arme la date au dernier jour du mois contenu

_ op√©rations avec les ¬´INTERVAL¬ª :
	uneDate + INTERVAL 'nb' [YEAR|MONTH|DAY|HOUR|MINUTE];
p.ex 
	table.colonneDate + INTERVAL '5' DAY


‚Ä¢ afficher composants d'une date ou timestamp :
	TO_CHAR( <date>, <format> )
p.ex
	TO_CHAR(colDate, 'HH24:MI')	//heure & minutes (format 24h)
	TO_CHAR(colDate, 'DD/MM/IYYY') // n¬∞jour/n¬∞mois/ann√©e s/ 4 chiffres
pour le format, cf
	https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements004.htm#i34510

‚Ä¢ SYSDATE ‚â† CURRENT_DATE :
_ SYSDATE :
	date courante sur le SERVEUR. Retour d√©pendant de NLS_DATE_FORMAT.
_ CURRENT_DATE :
	donn√©es dans la zone de temps de la SESSION



‚óè GROUP BY / ORDER BY :
‚Ä¢ optimisation possible :
Utiliser une sous-requ√™te contenant le GROUP BY, trier dans la requ√™te principale :

	-- ‚Ä¢ combien de courbes √† remonter chaque semaine ?
	SELECT TRUNC(DATE_COURBE, 'MONTH') Mois, COUNT(COURBE_ID) "nb courbes"
	FROM DIA_COURBES
	WHERE
	  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
	  AND EST_DERNIERE_VERSION = 1
	  AND PUBLIABLE = 1
	GROUP BY TRUNC(DATE_COURBE, 'MONTH')
	ORDER BY TRUNC(DATE_COURBE, 'MONTH') DESC;
devient :
	WITH unsorted as (
		SELECT
		  TRUNC(DATE_COURBE, 'MONTH') Mois,
		  COUNT(COURBE_ID)            "nb courbes"
		FROM DIA_COURBES
		WHERE
		  (TYPE_COURBE = 9 OR TYPE_COURBE = 10)
		  AND EST_DERNIERE_VERSION = 1
		  AND PUBLIABLE = 1
		group by TRUNC(DATE_COURBE, 'MONTH')
	)
	select *
	from unsorted
	ORDER BY Mois DESC;



‚óè SQLPLUS :
‚Ä¢ connexion :
sqlplus						‚Üí	√† la BdD par d√©faut
sqlplus <NOM>@<BdD>
sqlplus <NOM>/<MdP>@<BdD>	moins s√©curis√©



‚Ä¢ ex√©cuter un script :
	@<fichier>

‚Ä¢ les blocs de code doivent SE TERMINER PAR UN SLASH pour √™tre ex√©cut√©s :
si un fichier ne se termine pas par un slash, sqlplus affichera
 un prompt d√©butant par un n¬∞ de ligne en attendant plus de code.

‚Ä¢ largeur d'affichage des r√©sultats :
	set lin[|esize] <largeur> 

‚Ä¢ d√©finir une variable :
	def var = val
ou
	define var = val
	//l'utilisation de la variable se fait via le pr√©fixe & :
	... &var ...
	

‚óè PL/SQL ‚Äì structures :
‚Ä¢ variables :
	DECLARE
		nom TYPE;
		...

‚Ä¢ conditions :
	IF ... THEN
		...
	[ELSIF ...]
	[ELSE]
		...
	END IF

‚Ä¢ boucles :
	LOOP
		...
		EXIT WHEN ...;
	END LOOP;
	
	
‚óè PL/SQL ‚Äì divers :

‚Ä¢ ex√©cuter une proc√©dure :
	execute <nomProc>

‚Ä¢ proc√©dure nomm√©e == proc√©dure stock√©e :
CREATE OR REPLACE PROCEDURE [|sch√©ma.]nomProc√©dure [|(params...)] IS
BEGIN
	...
END;
	
CREATE OR REPLACE FUNCTION [|sch√©ma.]nomFonction [|(params...)]
	RETURN number IS
(...)

‚Ä¢ proc√©dure anonyme :
fonction d√©marrant directement par un ¬´BEGIN¬ª, directement ex√©cut√©e, pas stock√©e :

-- pour sqlplus ou sqlDeveloper : 
set serveroutput on;

-- fonction anonyme
BEGIN
    DECLARE
        -- r√©cup√®re la liste de toutes les paires EDA/EDE utilis√©es par les liens
        CURSOR pairList IS
            SELECT DISTINCT lbd.bae_id, lbd.dre_id 
            FROM link_bae_dre lbd
            ORDER BY lbd.bae_id, lbd.dre_id ;

        pair_bae_id number(19,0);
        pair_dre_id number(19,0);

        lastLbdId number(19,0);
        lastEndDate date;

    BEGIN
        open pairList;
        -- boucle √† travers la liste de paires EDA/EDE
        loop
            fetch pairList into pair_bae_id, pair_dre_id;
            EXIT WHEN pairList%NOTFOUND;
            
            -- infos : affiche chaque paire EDA/EDE trait√©e
            dbms_output.put_line( chr(10) || '‚óè paire ' || pair_bae_id || '/' || pair_dre_id || ' : ');

            -- ID et date de fin du dernier lien trait√© dans la boucle ci-dessous
            -- (ordonn√©s par dates croissantes de d√©but et de fin)
            lastLbdId := NULL;
            lastEndDate := NULL;

            -- boucle √† travers les liens relatifs √† une m√™me paire EDE/EDA,
            -- ordonn√©s par date croissante
            for line in (
                select * from link_bae_dre lbd
                    where lbd.dre_id = pair_dre_id and lbd.bae_id = pair_bae_id
                    order by lbd.lbd_start_date, lbd.lbd_end_date,lbd.lbd_id
            )
            loop
                -- infos : lien trait√©
                dbms_output.put_line(
                    'lbd_id = ' || line.lbd_id ||
                    ', lbd_bae_id = ' || line.bae_id ||
                    ', lbd_dre_id = ' || line.dre_id ||
                    ', lbd_start_date = ' || line.lbd_start_date ||
                    ', lbd_end_date = ' || line.lbd_end_date
                );
                
                if (lastLbdId is not null)
                then
                    -- cl√¥t le lien pr√©c√©demment examin√© s'il est encore ouvert
                    -- √† la date de d√©but du lien en cours, en armant sa date de
                    -- fin au jours pr√©c√©dant la date de d√©part du lien en cours
                    if line.lbd_start_date <= lastEndDate
                    then
                        -- infos : requ√™te ex√©cut√©e
                        dbms_output.put_line(
                            '    ‚Ä¢ requ√™te ex√©cut√©e : ' ||
                            'update link_bae_dre set lbd_end_date = ' ||
                            (line.lbd_start_date - interval '1' day) ||
                            ' where lbd_id = ' || lastLbdId
                        );
                        update link_bae_dre set lbd_end_date = (line.lbd_start_date - interval '1' day) where lbd_id = lastLbdId;
                    end if;
                end if;
               
               lastLbdId := line.lbd_id;
               lastEndDate := line.lbd_end_date;
            end loop;

        end loop;
    END;
    -- ins√©rer COMMIT ici si le script est satisfaisant
    -- COMMIT;
END;
/

