‚óè IMPORTER UN DUMP :
	impdp <utilisateur>/<MdP>@<h√¥te> directory=<dump_dir> dumpfile=<dump.dmp> \
		[logfile=<log.log>] schemas=CREMA,CREMA_LEC,CREMA_EAI \
		[ TABLE_EXISTS_ACTION=REPLACE ]
o√π
 <dump_dir> est le dossier contenant le dump √† importer,
 <dump.dmp> le fichier .dmp pr√©sent dans ce dossier
TABLE_EXISTS_ACTION=REPLACE :
	permet de remplacer les tables d√©j√† existantes (l'action par d√©faut est de les conserver)


‚óè DROP :
‚Ä¢ utilisateur :
	DROP USER <utilisateur> CASCADE;
‚Ä¢ table :
	PURGE TABLESPACE <table>;

‚Ä¢ espace de tables :
	DROP TABLESPACE <espaceDeTables> [INCLUDING CONTENTS [AND DATAFILES] [CASCADE CONSTRAINTS]];



‚óè FAITS NOTABLES DU SQL ORACLE :
¬´ uncommited ¬ª par d√©faut.

‚Ä¢ limiter le nombre de lignes du r√©sultat :
WHERE ROWNUM < ùëõ

OFFSET premLn ROWS FETCH NEXT nbLn ROWS ONLY;

FETCH FIRST num% PERCENT ROWS ONLY;



‚óè FONCTIONS :
‚Ä¢ calcul de dates :
	LAST_DAY(date) ‚Üí arme la date au dernier jour du mois contenu

_ op√©rations avec les ¬´INTERVAL¬ª :
	uneDate + INTERVAL 'nb' [YEAR|MONTH|DAY|HOUR|MINUTE];
p.ex 
	table.colonneDate + INTERVAL '5' DAY


‚Ä¢ afficher composants d'une date ou timestamp :
	to_char( <date>, <format> )
p.ex
	to_char(colDate, 'HH24:MI')	//heure & minutes (format 24h)
	to_char(colDate, 'DD/MM/IYYY') // n¬∞jour/n¬∞mois/ann√©e s/ 4 chiffres
pour le format, cf
	https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements004.htm#i34510

‚Ä¢ utiliser ¬´ to_date( <date>, <format>) ¬ª :
bonne pratique pour se rendre ind√©pendant du format de date par d√©faut.
p.ex,
	to_date( '14/10/2010', 'dd/MM/yyyy')



‚óè PL/SQL :
‚Ä¢ fonction nomm√©e == fonction stock√©e :
CREATE OR REPLACE FUNCTION closeInterlappingLinksBaeDre
	RETURN number IS
(...)

‚Ä¢ fonction anonyme :
fonction d√©marrant directement par un ¬´BEGIN¬ª, directement ex√©cut√©e :

-- pour sqlplus ou sqlDeveloper : 
set serveroutput on;

BEGIN
	DECLARE
		-- a cursor is used to walk a list of row results
		CURSOR pairList IS
		    SELECT DISTINCT lbd.bae_id, lbd.dre_id 
		    FROM link_bae_dre lbd
		    ORDER BY lbd.bae_id, lbd.dre_id ;

		pair_bae_id number(19,0);
		pair_dre_id number(19,0);

        lastLbdId number(19,0);
        lastEndDate date;

    BEGIN
        open pairList;
        loop
            fetch pairList into pair_bae_id, pair_dre_id;
            EXIT WHEN pairList%NOTFOUND;
            
            -- debug
            dbms_output.put_line( chr(10) || '‚óè paire ' || pair_bae_id || '/' || pair_dre_id || ' : ');

            -- ID and end date of the last parsed link_bae_dre (ordered by lbd_start_date ASC, lbd_end_date_ASC)
            lastLbdId := NULL;
            lastEndDate := NULL;

            
            for line in (
                select * from link_bae_dre lbd
                    where lbd.dre_id = pair_dre_id and lbd.bae_id = pair_bae_id
                    order by lbd.lbd_start_date, lbd.lbd_end_date,lbd.lbd_id
            )
            loop
                dbms_output.put_line(
                    'lbd_id = ' || line.lbd_id ||
                    ', lbd_bae_id = ' || line.bae_id ||
                    ', lbd_dre_id = ' || line.dre_id ||
                    ', lbd_start_date = ' || line.lbd_start_date ||
                    ', lbd_end_date = ' || line.lbd_end_date
                );
                
                if (lastLbdId is not null)
                then
                    -- close the previous link_bae_dre if it is still open
                    -- at the start date of the current one
                    if line.lbd_start_date <= lastEndDate
                    then
                        dbms_output.put_line(
                            '    ‚Ä¢ requ√™te ex√©cut√©e : ' ||
                            'update link_bae_dre set lbd_end_date = ' ||
                            (line.lbd_start_date - interval '1' day) ||
                            ' where lbd_id = ' || lastLbdId
                        );
                        
                    end if;
                end if;
               
               lastLbdId := line.lbd_id;
               lastEndDate := line.lbd_end_date;
            end loop;

        end loop;
    END;
END;


