GIT reconnait les renommages de fichier (ou les changement puis renommage)
Ã  condition que l'on Â«git add <nouveauNom>Â» avant la commit.


â€¢ gitHub : dÃ©pÃ´ts publics gratuits, dÃ©pÃ´ts privÃ©s payants
â€¢ gitLab, bitBucket : basÃ©s sur git eux aussi ; dÃ©pÃ´t privÃ© gratuit.

â— VOCABULAIRE :
Â  Â« staging area Â» / index :
	 contient les changements qui seront inclus dans le prochain commit
  unstaged :
	 un fichier modifiÃ© mais non enregistrÃ© par Â« git add Â»
  staged :
	 un fichier modifiÃ© et enregistrÃ© dans l'index via Â« git add Â»
â€¢ PR = Pull Request


â— TRAVAIL DISTRIBUTÃ‰ :
Un dÃ©pÃ´t n'est pas forcÃ©ment distant, ce peut Ãªtre un chemin local.
Â  git remote -v		liste dÃ©pÃ´ts distants et sources associÃ©es

â€¢ajouter-supprimer-renommer dÃ©pÃ´ts distants :
On peut avoir plusieurs dÃ©pÃ´ts distants !
Â  git remote add <alias> <url-dÃ©pÃ´t-distant>
	â†’ par convention, on nomme le 1er distant Â«originÂ»

Â  git remote rm <alias>
  git remote rename <de> <vers>

Â  git pull [distant | ] :
 	systÃ©matique avant de push, pour vÃ©rifier/corriger les conflits

Â  git fetch [dÃ©pÃ´t|]	rÃ©cupÃ¨re la liste des branches
  git fetch -p			"	"	" ET vide le cache des rÃ©fÃ©rences inexactes


â€¢ pousser vers dÃ©pÃ´t distant :
La 1Ã¨re fois, il faut lier la branche distante (dans le dÃ©pÃ´t distant) Ã  la
 branche locale :
	git push -u <nomDÃ©pÃ´t> <branche>
p.ex,
	git push -u origin nomBranche
pour le dÃ©pÃ´t "origin"
ensuite, un simple Â« git push Â» suffira.

Mais on peut aussi â†“ :

â€¢ ajouter une nouvelle branche au dÃ©pÃ´t distant :
	git push --set-upstream <origin> <branche>

â€¢ tÃ©lÃ©charger une nouvelle branche distante :
	git checkout -t <origin>/<nouvelleBranche>

â€¢ tirer les changements de la branche <master> distante
 vers la branche <dev> locale :
	git checkout dev; git pull origin master


â€¢ tÃ©lÃ©verser TOUTES les branches :
	git push --all origin

â€¢ git remote get-url <branch, p.ex origin> :
 affiche l'URL du dÃ©pÃ´t distant

â€¢ renommer une branche en local et en distant :
	git branch -m <ancienNom> <nouveauNom>	#renommage local
	git push <origin> :<ancienNom>			#suppression de l'ancienne branche
	git push --set-upstream <origin> <nouveauNom>
					# pousse la nouvelle branche locale et arme le suivi distant


â— NETTOYAGE DE BRANCHES :
Supprimer les branches supprimÃ©es, vider le cache de branches distantes :

â€¢ lister les branches dÃ©jÃ  fusionnÃ©es :
	git branch --merged

â€¢ lister les rÃ©fÃ©rences vers branches distantes :
	git branch -r

â€¢ vider le cache des branches distantes :
	git remote prune <origin>

(voir aussi git fetch -p)


â— OPTIMISATION / NETTOYAGE DE DÃ‰PÃ”T LOCAL :
	git gc --aggressive
â†’ suppression d'objets inutilisÃ©s, compressions de divers fichiers.



â— fusion de diffs en conflit :
AprÃ¨s un push/pull/merge provoquant des conflits,
 git indique dans le fichier mergÃ© les parties en conflit par
	<<<< HEAD
	version m
	==========
	version n
	>>>>>>>>>> <commit>

â€¢ AprÃ¨s correction manuelle,Â un nouveau git add [.|fichiers]
 indique Ã  git que la correction est effectuÃ©e.


â€¢ rÃ©cupÃ©rer la branche distante, dans son Ã©tat le plus rÃ©cent, sur laquelle
est basÃ©e la branche locale, puis lui applique tout nos changements locaux :
	git pull -rebase



â— CONFIGURATION GIT :
 git config [--system|--global|--local] <NOM> <VALEUR>
	--global : pour l'utilisateur
	--local : pour le dÃ©pÃ´t

â€¢ configurer au moins user.name et user.email ...Â 
 git config --global user.name <nom>

â€¢ autres options utiles :
	core.editor 		vim
	color.ui			true
	diff.mnemonicPrefix true  :
		cmp de branches : iâ†’index,wâ†’ working dir, hâ†’head
	autocrlf			input  :  CRLF â†’ LF

â€¢ configuration globale :
dans ~/.git,
	~/.config/git/
(dont ~/.config/git/ignore listant les fichiers/dossiers Ã  ignorer en tout projet)
â€¢ configuration d'un projet :
dans .git/gitconfig


â€¢ ne pas retaper son pseudo lors de l'authentification d'un projet :
L'authentification est gÃ©rÃ©e sÃ©parÃ©ment pour chaque dÃ©pÃ´t source.
â†’ Ã©diter ~/.git/gitconfig, toutes les sections [remote "nomOrigin"] :
glisser le nom d'utilisateur dans l'URL faÃ§on <protocole>://<pseudo>@<site>,
sous encodage URL pour les caractÃ¨res non-ASCII :

	[remote "origin"]
	url = https://monochrome%40orange.fr@gitlab.bordeaux.sqli.com/jns-bank.git
â†’ pour un compte nommÃ© Â« monochrome@orange.fr Â» !


â€¢ .gitkeep :
	simple convention : git n'indexe pas les dossiers vide,
		â†’ pour pouvoir indexer un dossier vide, on y place un Â«.gitkeepÂ»



â— .GITIGNORE :
â€¢ commentaire :
lignes DÃ‰BUTANT par un #
â€¢ attention aux espaces, qui sont considÃ©rÃ©s comme faisant partie des motifs !
	Y compris en fin de ligne.
â€¢ Â« xxx/** Â» â†’ un dossier et tout ses dossiers
		/**/*.log	â†’ ignorer tt les .log des sous-dossiers



â— initier le contrÃ´le de rÃ©vision :
Se placer ds le dossier concernÃ©, puis :
Â 	git init
	(Ã  ce moment on peut utiliser Â« git config --local xxx Â» ...)
	git add <xxx>		#ajoute Â«xxxÂ» aux fichiers surveillÃ©s. par exemple Â« . Â» !
	git commit			#1er commit !

â€¢ cloner un dÃ©pÃ´t GIT :
	git clone https//xxxxxxx

â€¢ crÃ©er une branche :
	git branch [nom] [nomParente]

â€¢ passer dans une branche (ou commit) :
	git checkout [nom]
pour ne modifier qu'un seul fichier :
	git checkout <commit> <fic>



â— DÃ‰TRUIRE UNE BRANCHE LOCALE OU DISTANTE :
â€¢ locale :
Â  git branch -d <branche>
 	son contenu doit avoir Ã©tÃ© fusionnÃ© dans sa branche parente ou dans HEAD
  git branch -D <branche>
 	raccourci pour Â« git branch -d --force Â»

â€¢ DISTANTE :
	git push -d <origin> <branche>



â— MONTRER LES CHANGEMENTS EFFECTUÃ‰S ...
â€¢ ... mais pas enregistrÃ©s dans l'index :
Â 	git diff
â€¢ ... et prÃªt Ã  Ãªtre commitÃ©s :
Â 	git diff --cached

â€¢ lister les fichiers diffÃ©rant d'une branche Ã  une autre :
	git diff --name-status <brancheA> <brancheB>
â€¢ diff entre 2 branches :
	git diff <brancheA> [brancheB|]
â€¢ pour un fichier :
	git diff <commitA> <commitB> -- <chemin>

â€¢ afficher diffÃ©rences entre 2 fichiers de 2 branches :
	git diff <branche1>:<fic1> <branche2>:<fic2>

â€¢ afficher le contenu d'un commit (ou de tous) :
	git show <commit>
	git show
	
â€¢ lister les fichiers modifiÃ©s par une commit :
	git show --name-only <commit|HEAD|etc.>
	git show --name-only --pretty="" <commit|HEAD|etc.> | sort | uniq

â€¢ afficher un fichier d'une autre branche (ou le recopier) :
	git show <branche>:<fic> [|><nouvelleCopie>]



â— SYNONYMES :
	HEAD	@
	HEAD~	HEAD^1	derniÃ¨re commit avant HEAD



â— ajouter des fichiers oubliÃ©s Ã  la derniÃ¨re commit :
	git add <...>
	git commit --amend --no-edit	** NE JAMAIS FAIRE Ã‡A SUR COMMIT PUSHÃ‰E **



â— annuler les changements d'un fichier indexÃ© ou non :
	git checkout [HEAD|branche|commit|...] -- <fic>
ou
	git checkout <fic> qui peut Ãªtre confondu avec un checkout de branche si homonymie
==
	git checkout -- <fic>



â— dÃ©faire un Â« git add Â» â€“ retirer un fichier du suivi avant commit :
	git reset <fic>



â— ANNULER UN/DES COMMITS :
â€¢ en retirant le commit de l'historique ET LES CHANGEMENTS :
	git reset --hard HEAD~1			#annuler le derniers commits
	git reset --hard <commit>

â€¢ annuler le commit mais GARDER LES CHANGEMENTS :
	git reset --soft <commit>

â€¢ annuler une PLAGE de commits :
	git reset [--hard|--soft] commit..commit
p.ex :
	git reset --hard HEAD~3..HEAD~5

â€¢ annuler un commit dÃ©jÃ  PUSHÃ‰ :
	git reset --hard <commit, p.ex HEAD~2>
	git push -f

â€¢ juste pour un fichier :
	git reset --[soft|hard] -- <fichier>



â€¢ en retournant sur un commit prÃ©cÃ©dent :
	git checkout <commit d'avant>
	[faire ses changements ; commiter ]
Mais il faut toujours qu'un commit soit liÃ© Ã  une branche pour ne pas Ãªtre supprimÃ© par le ramasse-miettes : il faut donc crÃ©er une branche :
	git checkout -b <nouvelleBranche>

â€¢ en annulant le dernier commit via un autre commit :
Â«git revertÂ» ne supprime pas la commit de l'historique, mais ajoute une commit
dÃ©faisant la prÃ©cÃ©dente.
	git revert HEAD		â†’	nouveau commit annulant le dernier

â— FUSIONNER DES COMMITS :
â€¢ git rebase -i <premierCommit> :
	-i pour Â«--interactiveÂ»
L'Ã©diteur ouvert va permettre de choisir les diffÃ©rentes opÃ©rations Ã  appliquer,
(p.ex Â«squashÂ» pour fusionner des commits.)

p.ex
	git rebase -i HEAD~2
pour fusionner les 2 derniers commits.




â— COPIER UN FICHIER ENTRE BRANCHES :
	git checkout <branche|commit> -- <fic>


â— SUPPRIMER UN FICHIER DE TOUTE L'HISTORIQUE :
â€¢ supprimer un fichier du suivi, mais sans le faire disparaitre du disque
 ni de l'historique :
	git rm --cached <fic>
	git commit ...
	git push

â€¢ supprimer totalement un fichier du dÃ©pÃ´t GIT y compris de l'historique :
	<TODO>


â— git stash :
Les Â« stash Â» / Â« planques Â» sont toujours en local, jamais pushÃ©s ;
Ils concernent les fichiers stagÃ©s et non stagÃ©s,
 mais PAS les fichiers non-suivis ou ignorÃ©s par GIT.
Â  git stash :
	 enregistre tout les changements non commitÃ©s (stagÃ©s et non-stagÃ©s),
	 sauf ceux des fichiers non-suivis ou ignorÃ©s.
  git stash -u :
	 enregistre les changements de TOUT les fichiers.
â€¢ bonne pratique :
	nommer les stash via Â« git stash push -m <msg> Â»

Â  git stash pop [stash@{ğ‘›}] :
	 applique les changements du [dernier|] stash et le supprime
  git stash apply [stash@{ğ‘›}|] :
	 applique le [dernier|] stash sans le supprimer

Â  git stash list

Â  git stash drop [stash@{ğ‘›}|]
  git stash clear : supprime tout les stash

Â  gti stash branch [stash@{ğ‘›}|] : crÃ©Ã© un branche d'un stash

Â  git stash show
  git stash -p (...) : pour stasher changements partiels


â— TAGS :
Sont appliquÃ©s Ã  la branche ou au commit en cours.
Â  git tag <nom>			â†’ appliquÃ© Ã  la branche/commit en cours
  git tag --delete <nom>
  git tag list ou Â« git tag Â»

â€¢ LES TAGS NE SONT PAS POUSSÃ‰S AUTOMATIQUEMENT.
Â  git push origin <tagName>		pousser UN tag
  git push --tags				pousser TOUT les tags (attention !)

Â  git checkout tags/<nomTag>
  git checkout tags/<nomTag> -b <nouvelleBranche> :
		crÃ©Ã© une nouvelle branche Ã  partir du tag



â— MONTRER LES COMMITS PRÃ‰SENTS DANS LA BRANCHE "Old" MAIS PAS LA "Nouv" :
Â  git log <Nouv>..<Old>
â€¢ montrer le diff de ces commits :
Â  git diff <Nouv>...<Old>	â† attention : 3 points.


â— LISTER LES BRANCHES CONTENANT DES COMMITS NON MERGÃ‰S dans la branche <cible> :
Â  git branch --no-merged <cible>


â— LISTER branches et commits :
â€¢ lister les branches :
	git branch
â€¢ et les commits (Ã©ventuellement d'une branche diffÃ©rente) depuiq HEAD :
	git log
	git log --oneline
	git log <branche>

â— LISTER LES BRANCHES CONTENANT UN CERTAIN COMMIT :
â€¢ dans les branches locales :
	git branch --contains <commit>
â€¢ dans les branches distantes :
	git branch -r --contains <commit>


â— LISTER LES COMMITS AYANT ENTRAINÃ‰ CERTAINES MODIFICATIONS :
Pas d'espace entre l'option et le paramÃ¨tre !

â€¢ chercher une expression rationnelle dans le texte du patch :
	git log -G<regex>

â€¢ chercher diffÃ©rence sur NOMBRE D'OCCURENCES D'UNE CHAÃNE :
	git log -S<chaÃ®ne>

â€¢ chercher les commits concernant un fichier :
_ sans tenir compte des changements de nom :
	git log -- <fic-ou-motif>
_ en suivant les renommages :
	git log --full-history -- <fic>

â€¢ chercher les commits concernant une **FONCTION** :
	git log -L :<regExFonction>:<cheminFichier>

â€¢ CHERCHER LE COMMIT AYANT SUPPRIMÃ‰ UN FICHIER :
	git log --full-history -1 -- <fic>
-1 pour n'afficher que le dernier commit concernant ce fichier.


â— CHERCHER UN FICHIER (PEUT-ÃŠTRE NON EXISTANT DANS LA BRANCHE ACTUELLE)
 DANS TOUTES LES BRANCHES :
	git log --all -- <motifFic>
p.ex :
	git log --all 'src/*.inc'

â€¢ chercher la commit dans laquelle un fichier a Ã©tÃ© crÃ©Ã© :
	git log --oneline <fic> | tail -1
ou, plus Ã©lÃ©gant,
	git log -1 --reverse --pretty=oneline <fic>



â— lister les fichiers sous contrÃ´le de version :
Â 	git ls-tree -r [HEAD|nom-de-branche] --name-only
 Â«HEADÂ» pour la branche actuelle,
 et [Nombranche] pour ceux de la branche/commit/etc. nommÃ©e.

â— git status :
Liste, entre autres, les fichiers non suivis,
 s'il y a des changements non commitÃ©s, ...

â€¢ gÃ©nÃ©rer les patches permettant de parvenir Ã  la branche actuelle
depuis le dÃ©part, 1 patch/commit :
	git format-patch origin

â€¢ enregistrer un commit :
Â 	git commit -a -m "<texte descriptif>"		# -a : pour "tout les fichiers"
 enregistre dans le commit tt les changements dÃ©tectÃ©s,
 au contraite de
	git add <xxx> <yyyy> <zzz>
	git commit
 qui ajoute Ã  l'index les modifications de <xxx>, <yyy>, <zzz> et les commits.

