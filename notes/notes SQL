â— (client MySQL ln2Comm) :
mysql -u <user> -p<MdP, sans espace avant> -h <host> -P <nÂ°Port>  <BdD>


â™¦(MySQL) commandes notables :
	mysql -u <userW> -p		â†’ le Â«-pÂ» sans param fait demander le MdP
	source,	\.

â™¦(MySQL) changer le prompt :
	prompt <chaÃ®ne>,
	l'envVar $MYSQL_PS1,
	l'option --prompt="..."
	la configuration au sein d'un .cnf : prompt=

â™¦(MySQL sous Debian) fichiers de config :
MySQL lit tout les *.cnf sous /etc/mysql/ ;
/etc/mysql/my.cnf : pour la config personnalisÃ©e

â— mÃ©tacommandes SQLite & Cie :
Â«.tablesÂ» == Â«SELECT name FROM sqlite_masterÂ» â†’ liste les tables prÃ©sentes

â”Œâ”€â”€ la mÃªme chose Ã  peu de choses prÃ¨s :
â”‚Â«.schema <nomTable>Â» â†’ liste commandes ayant crÃ©Ã© la table
â”‚Â«pragma table_info(<nomTable>)Â» â†’ affiche la structure d'une table
â””â”€â”€

.databases â†’ liste des BD ouvertes



â— (sqlite) COMMANDES SPÃ‰CIFIQUES Ã€ L'INTERFACE EN LN-DE-COMM :
â€¢ EFFACER L'Ã‰CRAN :
	ctrl+L ...
â€¢ exÃ©cuter une commande du shell :
	.shell <commande>


â™¦(sqlite ?) formatage de la sortie de la commande SELECT :
Â 	.mode html|list|csv|column

Â 	.mode list â† .separator xxx (par ex : Â«\tÂ» ou Â«~Â» ...)
	.mode column â† .width [x1 x2 x3 ...] (largueur de chaque colonne possible ...)

â™¦(sqlite ?) affichage des noms de colonnes :
Â 	.headers [on|off]

â™¦(sqlite ?) redirection de la sortie vers un fichier :
Â 	.output <nomFichier>
 puis
	.output stdout
		pour rÃ©tablir sortie vers l'Ã©cran ...

â€¢Â table cotennant des champs ;
 enregistrements classÃ©s par Â«clÃ©sÂ» (l'Â«idÂ» est souvent la Â«clÃ© primaireÂ») ;
 chaque ligne est un Â«tupleÂ» ou un Â«enregistrementÂ» ;

â€¢ SQL / NoSQL :
_ SQL : pour donnÃ©es structurÃ©es. Les clÃ©s des enregistrements relient les
 diffÃ©rentes tables entre elles ; pas de redondance des donnÃ©es.
_ NoSQL : pour donnÃ©es brutes â€“ plus performant en lecture pour de gros volumes
 de donnÃ©es, mais plus lent en Ã©criture et en recherches sur les champs
 "secondaires" â†’ on y crÃ©Ã©e souvent plusieurs tables pour faciliter les
 difÃ©rentes recherches.



â— CLÃ‰ PRIMAIRE, CLÃ‰ SECONDAIRE, CLÃ‰ Ã‰TRANGÃˆRE :
â€¢ clÃ© primaire :
	PRI
Le champs (ou la combinaison de champs â€“ clef composite) permettant de
 rÃ©fÃ©rencer de maniÃ¨re non-ambigÃ¼e l'enregistrement
â€¢ clÃ© secondaire :
	SEC
Une clÃ© rÃ©fÃ©renÃ§ant un autre enregistrement de la mÃªme table
â€¢ clÃ© Ã©trangÃ¨re :
  MUL pour Â«MULtipleÂ», car plusieurs occurences d'une mÃªme valeur sont permises
Une clÃ© rÃ©fÃ©renÃ§ant un enregistrement d'une autre table


â— INDEX :
Ressources, comme les tables.
â€¢ Â« index couvrant Â» :
    index couvrant 2 colonnes ou plus.

CREATE INDEX ix_... ON table(colonne)
    


â—(MySQL) par dÃ©faut, les chaÃ®nes ne sont PAS stockÃ©es en UTF8 :
il faut indiquer l'encodage Ã  la crÃ©ation d'une table :
(et facultativement l'ordre de tri Ã  utiliser)
    CREATE TABLE tbl CHARACTER SET 'utf8' [| COLLATE ordreDeTi ] (...)

â— ENCODAGE DE CARACTÃˆRES (Â«CHARACTER SETÂ») ET ORDRE DE TRI (Â«COLLATEÂ») :
Â  SHOW CHARACTER SET [LIKE 'utf%' ];
  SHOW COLLATION [LIKE ...];

â€¢ encodage et ordre de tri utilisÃ©s par une BdD :
   SELECT @@character_set_database, @@collation_database;

â€¢ modifier l'encodage d'une BdD ou d'une table :
	ALTER [TABLE|DATABASE] <id> CHARACTER SET utf8mb4
	  COLLATE utf8mb4_general_ci;



â— VUE :
    CREATE VIEW nom AS SELECT ...
    
Table virtuelle (et dynamique) en L/E. 
Affiche, par exemple, le rÃ©sultat d'une requÃªte. Les changements rÃ©alisÃ©s dans
 la vue sont bien sÃ»r appliquÃ©s aux tables sous-jacentes !
_ on peut lui appliquer des droits via GRANT et REVOKE
    â†’ trÃ¨s utilisÃ© pour gÃ©rer la sÃ©curitÃ© Ã  une granularitÃ© infÃ©rieure
        Ã  celle de la table.

â€¢ VUES â‰  TABLE TEMPORAIRE :
_VUE :
    stockÃ©e ds la BdD, synchronisÃ©e avec les tables sous-jacentes.
_TABLE TEMPORAIRE :
    table indÃ©pendante, stockÃ©e en mÃ©moire le temps de la session ...

â— TABLE TEMPORAIRE :
â€¢(MySQL) :
    CREATE TEMPORARY TABLE tbl AS ( SELECT .... )
ou
    CREATE TEMPORARY TABLE tbl( ... )
â€¢(SQLserver):
avec SQLserver, les tables temporaires sont prÃ©fixÃ©es d'un diÃ¨se #
    CREATE #tbl ...
ou
    SELECT ... INTO #tbl FROM ...


â— CONSTRAINT :
_ Convention de nommage : ck_xxxx.
_ se placent aprÃ¨s les champs.
â€¢ PAR CONVENTION, une contrainte par colonne.

UNIQUE(champs)
CHECK(condition)    â†’ PAS IMPLÃ‰MENTÃ‰ PAR MYSQL !

    CREATE TABLE Test(
        userName varchar,
        count smallint,
        CONSTRAINT  ck_ref FOREIGN KEY(userName) REFERENCES tableUser(name),
        CONSTRAINT ck_null CHECK(champs IS NOT NULL),
        CONSTRAINT ck_champ2_sup_champ0 CHECK(champ2 >= champ0 ),
    )


â— ALIAS :
    tbl AS t
s'Ã©crit aussi
    tbl t


â— Texte comportant un mot-clef, ou des opÃ©rateurs, des caractÃ¨res blanc,
 ponctuation, accents, ... :
â€¢ encadrÃ© par des apostrophes 'xxx' : c'est une chaÃ®ne litÃ©rale.
	une apostrophe au sein de la chaÃ®ne sera doublÃ©e :
		l'a	â†’	'l''a'
â€¢ encadrÃ© par des guillemets "xxx" : c'est un identifiant.
	de mÃªme, un guillemet dans la chaÃ®ne sera doublÃ©.
		a"b"	â†’	"a""b"""

â€¢(SQLite, Âµsoft â€“ NON STANDARD) par des crochets [xxx] : identifiant.
â€¢(SQLite, MySQL â€“ NON STANDARD) par des accents graves `xxx` : identifiant.
Sous MySQL, cette technique â†‘ est nÃ©cessaire pour tout caractÃ¨re non ASCII.

â€¢ (MySQL) limitations sur longueur et casse des identifiants :
_ La plupart des identifiants sont limitÃ©s Ã  64 caractÃ¨res (sauf alias,
 qui sont la plupart du temps Ã  256 cars).

_Chaque BdD est un sous-rÃ©pertoire du dossier de travail MySQL
 (/var/lib/mysql par dÃ©faut), et chaque table correspond Ã  au moins
 un fichier ...
â†’ en fonction des systÃ¨mes de fichier, les noms de tables et de BdD
 seront ou non sensibles Ã  la casse.

_ noms de colonnes, fonctions stockÃ©es, noms d'Ã©vÃ©nements sont
 insensibles Ã  la casse.


â— Â« SELECT LAST_INSERT_ID() Â» :
Renvoit le 1er id en auto-incrÃ©ment de la derniÃ¨re requÃªte INSERT ou UPDATE ...
Unique par connection â†’ pas de problÃ¨me de concurrence lors d'accÃ¨s parallÃ¨les !



â— COUNT([*|ALL|(DISTINCT)?expressionRenvoyantUneColonne]) :
Â  * :			les lignes,
  ALL :			ttes les valeurs (par dÃ©faut)
  expr :		une colonne ou qqch chose assimilable
  DISTINCT expr : les valeurs uniques de l'expression
â€¢ les FONCTIONS D'AGRÃ‰GATION COUNT(), SUM(), AVG(), ...
 peuvent fonctionner avec un Â« GROUP BY Â»


â— GROUP BY, ORDER BY sont cumulables :
p.ex	SELECT region, ville, COUNT(*) AS nbEleves FROM Ã©coles
		GROUP BY region
		GROUP BY ville
		HAVING nbEleves > 10
		ORDER BY region ASC
		ORDER BY ville ASC;
â€¢ GROUP BY ... WITH ROLLUP :
    WITH ROLLUP introduit des sous-totaux


â— SOUS-REQUÃŠTES : requÃªte entre parenthÃ¨ses !
Utilisables dans les clauses SELECT, FROM, WHERE.

â€¢ sous-requÃªtes SIMPLES :
    La sous-requÃªte peut Ãªtre exÃ©cutÃ©e seule. Elle sera exÃ©cutÃ©e avant la
requÃªte principale, puis ses rÃ©sultats y seront utilisÃ©s.
â€¢ ou CORRÃ‰LÃ‰ES, SYNCHRONES :
    La sous-requÃªte fait rÃ©fÃ©rence Ã  des colonnes/tables de la requÃªte
principale. Comme elle y est liÃ©e, le moteur SGBD va considÃ©rer les 2 requÃªtes
comme un tout et OPTIMISER l'accÃ¨s en BdD.
 

p. ex :
	SELECT nom FROM gens WHERE adresse IN ( SELECT nom FROM villes
		WHERE population > 5000 );
ou
	SELECT nom FROM Ã Copier WHERE 1 = ALL(
		SELECT name FROM from pragma_table_info('Ã Copier')
			WHERE type="INTEGER" AND NOT name="typeCopie" );
â†’ renvoit les noms des enregistrements dont toutes les colonnes de type
 "ENTIER" (sauf typeCopie) valent 1.

â€¢(sqlite) sqlite n'a pas de ALL() !



â™¦ EXPRESSIONS RATIONNELLES dans le paramÃ¨tre de Â«LIKEÂ» :
** INSENSIBLE Ã€ LA CASSE **
les expressions rationnelles s'Ã©crivent entre guillements simples Â«'Â».
	   % remplace *,
	et _ remplace ?

â™¦ SELECT sert aussi Ã  afficher du texte brut.

â€¢ SELECT expression AS nouveauNom ...
    SELECT tbl.nom, t2.nom 

â— clauses notables :
	ORDER BY "xxx" [ASC|DESC]	â† Â«ascendantÂ»/Â«descendantÂ»
â€¢ pas plus de ğ‘› entrÃ©es renvoyÃ©es :
	MySQL :     LIMIT ğ‘›
	Oracle :    WHERE ROWID < ğ‘›
	SQLserver : SELECT TOP ğ‘› ...


â— WHERE :
	BETWEEN ... AND ...
	IN ( ..., ..., ..., ... )
	LIKE
	=, <>, =>, <=, >, <
    AND, OR, NOT,
    ... IS NULL / IS NOT NULL,
    ...
â€¢ WHERE EXISTS (requÃªte)
    EXISTS(...) est vrai quand la sous-requÃªte ne renvoit pas NULL 



â— DISTINCT :
	SELECT DISTINCT(xxx) FROM yyy;


â— JOKERS :
	%	â†’ Ã©quivalent *
	_	â†’ Ã©quivalent ?


â— JOINTURE :
â€¢ jointure par dÃ©faut :
	SELECT * FROM Ã©lÃ¨ves, Ã©coles (...)
est Ã©quivalent Ã 
	SELECT * FROM Ã©lÃ¨ves JOIN Ã©coles (...)
â€¢ JOIN tout seul â†’ Â« INNER JOIN Â»


â€¢ clause ON :
 pour ne pas mettre la condition d'Ã©galitÃ© de deux clÃ©s dans la clause WHERE.
â€¢ clause USING( xxx ) :
Quand le nom de colonne est le mÃªme dans les 2 tables, on peut s'en
 servir de raccourci pour
	ON ( tbl1.xxx = tbl2.xxx )

â€¢Â  SELECT h.prenom, h.nom,  s.nom,  r.date_et_heure, r.duree
	FROM reservations AS r
	JOIN salles AS s ON r.id_classe = s.id
	JOIN humains AS h ON h.id = r.id_reservant;

	SELECT * FROM Ã©lÃ¨ves JOIN Ã©coles ON Ã©lÃ¨ves.id_Ã©cole = Ã©coles.id
	  WHERE Ã©cole.nom = 'Bordeaux';
â€¢ elles sont imbricables :
rÃ©cupÃ¨re les noms d'Ã©lÃ¨ves apprenant le PHP,
 au sein d'une BdD contenant les tables Ã©leve â†’ Ã©cole â†’ language :
 	SELECT nom FROM Ã©lÃ¨ves
		JOIN Ã©cole ON Ã©lÃ¨ve.id_Ã©cole = Ã©cole.id
			JOIN language ON Ã©cole.id_lang = language.id
				WHERE language.nom = 'PHP';

â€¢ diffÃ©rents types :
_ [INNER|] JOIN	â†’ retourne les enregistrements pour lesquels la condition
    du ON est remplie dans les 2 tables droite et gauche
_ JOIN â†’	affiche aussi les enreg de la table de gauche ne remplissant
    pas la condÂ°
_ RIGHT JOIN â†’ affiche aussi les enreg de la tbl de droite ne remplissant pas ...
_ CROSS JOIN se comporte comme un INNER quand on lui ajoute une condition.
_ SELF JOIN :
    se fait en donnant deux alias diffÃ©rents Ã  la mÃªme table au sein du FROM :
        Â« FROM tbl t1, tbl t2 Â»
_ THETA JOIN

â— OPÃ‰RATEURS D'ENSEMBLE :
â€¢ UNION :
	union de 2 requÃªtes, sans doublons.
â€¢ UNION ALL :
	on laisse les doublons.
â€¢ UNION peut aussi crÃ©er une ensemble, qui sera traitÃ© comme une table
    â€“ pratique quand on a les droits de crÃ©er une table (mÃªme temporaire) 

â€¢ INTERSECT,
  MINUS



â— FONCTIONS :
_ ROUND(ğ‘›), ROUND(ğ‘›, nb)
_ ISNULL(â‚™) renvoit ğ‘›, ou 0 si le nombre ğ‘› est null
    â†’ ( salaire + isnull(prime) ) renvoit tjr un nombre mÃªme si Â«primeÂ» est null
_ COALESCE(v1, v2, ...)
    renvoit le premier vğ‘› non null
_ length()
_ replace()
_ substring(ch, i, nb) â† index **Ã  partir de 1**
_ left(ch, 1)          â† substr() depuis la gauche
_ 
_ concat(ch1, ch2)

_ PARSE(ch, typeDest)
  TRY_PARSE(ch, typeDest) â†’ ne gÃ©nÃ¨re pas d'erreur mais un NULL si le parse Ã©choue   


â€¢ fonctions mathÃ©matiques :
	COS(), EXP(), LOG(), PI(), ...
â€¢ fonctions de gÃ©olocalisation,
â€¢ de date :
	NOW()	â†’  horodatage actuel,
	    DATE( NOW() ) â†’ date actuelle
	    YEAR( NOW() ) â†’ une annÃ©e sous forme de nombre 
	YEAR(),
	MONTH(),
	DATEDIFF() â†’ diffÃ©rence entre 2 dates,
	
â€¢ FONCTIONS D'AGGRÃ‰GATION :
	COUNT(), SUM(), MAX(), MIN(), AVG(), ...
â€¢ HAVING :
    s'utilise avec les fonctions d'aggrÃ©gations comme le WHERE.
     

â— FONCTIONS DE TRAITEMENT DE TEXTE :
	replace(ch,de,vers)
	ltrim(ch, Ã suppr), rtrim(ch, Ã suppr),
		ou [lr]trim(ch) qui s'occupe des blancs
	repeat(ch,nb)
	substring(ch,pos,nb), substring(ch,pos), ...
	upper(ch), lower(ch),
	...


â— TIMESTAMP VERS DATETIME OU DATE :
    SELECT leTimestamp, 
           FROM_UNIXTIME(leTimestamp) as val_datetime,
           CAST(FROM_UNIXTIME(leTimestamp) as date) as val_date
        FROM table




â— GROUP_CONCAT( tbl.champs [| SEPARATOR ch ] ) :
concatÃ©ne les lignes correspondant au champs donnÃ©,
    optionnellement sÃ©parÃ©es par une chaÃ®ne.


â—(sqlite) Â« pragma table_info(tbl) Â» :
	renvoit une table listant les colonnes de Â«tblÂ» et leurs attributs :
		cid	/ name / type / notnull / dflt_value / pk

â—(sqlite) compter le nb de colonnes d'une table:
	SELECT COUNT(*) FROM pragma_table_info("nomTable");
Le nom de la table doit Ãªtre encadrÃ© de guillemets (simples ou doubles),
 car pragma_table_info() est une fÂ°.


â—SQLite understands the following binary operat	ors,
 in order from highest to lowest precedence:
 [sans oublier les parenthÃ¨ses ...] ( xxx )
    || (CONCATÃ‰NATION de chaines !)
    *    /    % (modulo)
    +    -
    <<   >>   &    |
    <    <=   >    >=
    =    ==   !=   <>   IS   IS NOT   IN   LIKE   GLOB   MATCH   REGEXP
    AND
    OR
Supported unary prefix operators are these:
    -    +    ~    NOT



â™¦des exemples que j'ai utilisÃ©s :
Â« SELECT filename, entry_title, releaseDateObj FROM item
	WHERE filename LIKE '%ITEMA%' AND feed_id = 7958 ORDER BY filename; Â»
Â« select entry_title from item where feed_id = (select ufeed_id from rss_feed_impl
	where title = 'Sur les Ã©paules de Darwin'); Â»


â—(MySQL, SQLserver, Oracle) TRANSACTIONS AUTOMATIQUES :
_ MySQL, SQLserver :
Autocommit par dÃ©faut.
    â†’ Â« SET AUTOCOMMIT = 0 Â» avant toute transaction !
_ Oracle :
Â« uncommited Â» par dÃ©faut.
    â†’ aprÃ¨s tout UPDATE,INSERT,DELETE, il faut un COMMIT !

â€¢(MySQL) :
    SET SQL_SAFE_COMMIT = 0;
permet d'utiliser des DELETE au sein d'une transaction sans clef dans le WHERE.


â—(MySQL) TRANSACTIONS :
    SET AUTOCOMMIT = 0;
    SET SQL_SAFE_UPDATES = 0;
    START TRANSACTION;
	    DELETE FROM COMMERCIAUX WHERE COMMISSION > 5000;
        ROLLBACK;
    END TRANSACTION;


â— TYPES DE DONNÃ‰ES :
INTEGER/INT   4oct
SMALLINT      16b
BIGINT        8oct
(N)CHAR
(N)VARCHAR


â— MÃ‰TADONNÃ‰ES :
â€¢ le Â« dictionnaire Â» des donnÃ©es.
    SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE COLUMN_DEFAULT
        FROM IN
        SCHEMA.COLUMNS
        WHERE


â— CRÃ‰ATION / SUPPRESSION D'UNE TABLE EN MySQL :
  CREATE TABLE <MA_ION
	id INT PRIMARY KEY AUTO_INCREMENT,
			â†’ clÃ© primaire numÃ©rique : plus rapide pour les recherches
	nom VARCHAR(tMax),
	date DATE,			â†’ au format AAAA/MM/JJ
	info	TEXT		â†’ texte de taille arbitraire
  );

La taille des champs doit Ãªtre bien pensÃ©e â€“ les champs consomment de la place.

  DROP TABLE <table>;
  DROP DATABASE <Bdd>;

â— COMMANDES ADMINISTRATIVES :
Â  CREATE USER [IF NOT EXIST] <user> IDENTIFIED BY 'MdP'...
	â†’ il y a de nbx options pour spÃ©cifier les droits, la frÃ©quence de renouvellement du MdP, ...
	 Penser Ã  NE JAMAIS UTILISER Â«rootÂ» en tant qu'utilisateur !
  DROP USER;
  SET PASSWORD [FOR <user>] = PASSWORD('MdP');

Â  SHOW GRANTS [FOR CURRENT_USER];

â€¢ octroi de droits aux utilisateurs :
Â  GRANT ...		â†’ gestion des droits d'accÃ¨s
				â†’ aussi pour lister les utilisateurs.
	GRANT SELECT, UPDATE ON [ <BdD> | <BdD>.<tbl> ] TO <user@hÃ´te>;

Les droits de crÃ©ation & suppression de table au sein d'une BdD sont allouÃ©s
 un-Ã -un :
Â 	GRANT CREATE ON <BdD>.* TO <user@hÃ´te>;
	GRANT DROP ON <BdD>.* TO <user@hÃ´te>;

â€¢ spÃ©cifier l'utilisateur :
	testeur@localhost
	'testeur'@'localhost';
	'user'@'192.13.25.45';
_ % : joker pour Â« toutes adresses IP Â» ;
	'user1'@'%';

Â  SHOW DATABASES;
  SHOW TABLES [ FROM <BdD> ];

Â  SHOW [FULL] COLUMNS FROM [<BdD>.]<table>;
	â†’ montre la structure logique de la table
Â  DESCRIBE <table>;			â†’ itou

Â  ALTER TABLE <table> [ ADD ... | DROP ... | MODIFY ... ];

    ALTER TABLE tbl  CHANGE COLUMN col col DECIMAL(8,2);
est Ã©quivalent Ã 
    ALTER TABLE tbl  MODIFY col DECIMAL(8,2);


â€¢(MySQL) EXPORTER UNE BdD :
	mysqldump -u <user> [-p|] --databases <BdD> > <fic.sql> #avec un Â«SÂ»
â€¢(MySQL) et l'importer :
	mysql -u <user> [-p|] --database <BdD> < <fic.sql>


â— rÃ©initialisation du MdP root :
_Â arrÃªter le service
_Â mysqld_safe --skip-grant-tables :
	redÃ©marrer le dÃ©mon en mode sÃ»r, SANS charger la table de droits
	â†’ AUCUN contrÃ´le d'accÃ¨s !
_ use mysql;
  UPDATE user SET password = PASSWORD(MdP) WHERE user = 'root';
	â†‘ ceci ne tient pas compte du nom d'hÃ´te ...
_ flush privileges;
_ redÃ©marrer mysql en mode normal
