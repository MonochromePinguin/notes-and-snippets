â— cf Â«notes commandesÂ» pour les commandes externes ...


â— entrer une tabulation en ligne-de-commande BASH :
	Ctrl-V puis TAB (Ã§a marche avec ttes autres touches que TAB sauf entrÃ©e)


â— DIFFÃ‰RENCES ENTRE DASH & BASH :
â€¢pour extraire une sous-chaÃ®ne de $var dÃ©butant en x et de y caractÃ¨re :
	 ${var:x:y}		(x dÃ©bute Ã  0)	avec Bash,
	 expr substr $var x y	(x dÃ©bute Ã  1)	avec Dash (commande externe)
â€¢comparaison de chaÃ®nes :
	if [ $var == 'xxxxxx' ] est possible sous Bash,
	if [ $var = 'xxxxxx' ] seule option sous Dash (pas de double-Ã©gual Â«==Â» !)
â€¢pas de [[ ]],de tableaux, ...

â€¢ substitutions valables sous DASH :
	${var#motif}
	${var##motif}
	${var%motif}
	${var%%motif}
	${#var}
	${var:-defaut}, ${var:=default}, ${var:+defaut}, ${var:?[msg]}
	_ substitution arithmÃ©tique $(( ... ))



â— [[ ]] Vs [ ] :
â€¢ d'une maniÃ¨re gÃ©nÃ©rale (cf mes tests ds Â« docs & notes Â»),
 [[ ]] est plus rapide que [ ].

â€¢ Pas de dÃ©coupage en mot ni d'expansion des chemins avec [[ ]]
â€¢ les opÃ©rateurs || et && dans [[ ]] sont l'Ã©quivalent de -o et -a dans [ ],Â 
_Â Ã  la diffÃ©rence qu'avec [[ ]] l'Ã©valuation est court-circuitable ;
_Â tandis qu'avec [ ], les expressions sÃ©parÃ©es par des -a et -o produiront
 systÃ©matiquement leurs effets secondaires.



â— COMMANDES INTERNES BASH â€“ HISTOIRE:
â€¢history -wÂ  enregistre l'historique

â€¢ l'option shopt Â«histverifyÂ»,Â quand activÃ©e, fait que le rÃ©sultat d l'expansion
des commandes bang est affichÃ© pour Ã©dition au lieu d'Ãªtre exÃ©cutÃ© directement.

â€¢les commandes Â«bangÂ» :
Â 	!$				Dernier argument de la derniÃ¨re commande
	!^ ou !:1		Premier "	"	"	" (raccourci de !!:1)
	!*				tout les arguments	"	" (raccourci de !!:*)

Â 	!!	affiche la derniÃ¨re commande (utile dans Â« $(!!) Â» ).
	!-ğ‘›	"	" ğ‘›iÃ¨me prÃ©cÃ©dente commande
	!ğ‘›	"	" ğ‘›iÃ¨me commande de l'historique (0 == la plus ancienne)
	!<ch>	affiche la derniÃ¨re commande commenÃ§ant par <ch> ...
	!?<ch>	"	"	"	"   contenant le texte <ch>.
	^<chO>^<chR>^	"	"	", en remplacant <ch0> par <chR>

â€¢ modificateurs pour ces raccourcis â†‘â†‘â†‘ :
	:ğ‘›	extrait le ğ‘›iÃ¨me argument de ...
	:$	"  "  "  " dernier argument de ...	(raccourci :	!$ )
	:*	"  "  " tout les arguments de ...
	:%	"  "  " le mot correspondant Ã  la derniÃ¨re recherche !?<ch>?
		(par ex. : Â« cd !?Man?:% Â» â†’â†’ cd C/serveurMan si on a prÃ©cedemment
		 utilisÃ© Â« ls C/serveurMan Â»)


â— CONTRÃ”LE DE TÃ‚CHES ( Â«jobsÂ», en arriÃ¨re-plan / stoppÃ©es ) :
â€¢ Â«psÂ» Vs Â«jobsÂ» :
_ ps liste les PID des proc' en cours d'exÃ©cutÂ° rattachÃ©s au terminal courant,
_ jobs affiche les nÂ° de tÃ¢che et les listes de commandes correspondantes

Â  Ctrl-ZÂ stoppe un proc. (PID ou nÂ° de tÃ¢che %ğ‘›) pr le mettre en arriÃ¨re-plan,
  Ctrl-YÂ le stoppe dÃ¨s qu'il attend une entrÃ©e,
  et "fg %n"/"bg %n"Â (re)placent le job nÂ°"n" en avant-plan / arriÃ¨re-plan
   (ou %- [job prÃ©cedent], %<nom_exact>, %?<partie_du_nom>)
_ kill -STOP %n,
  kill %n		marchent tout aussi bien

_ disown %n	retire une tÃ¢che du contrÃ´le de BASH :
 n'est plus soumise Ã  bg / fg, invisible Ã  jobs,
 et ne reÃ§oit PAS de SIGHUP Ã  la fermeture du terminal.

_ shopt Â±huponexit	contrÃ´le si BASH envoit ou non ce signal Ã  sa terminaison,
 qd celle-ci est provoquÃ©e par l'interprÃ©teur lui-mÃªme â€“ par par le terminal !


â— COMMANDES INTERNES BASH :
â™¦ le programme Â«envÂ»Â liste les variables d'environnement que son parent
 lui a transmis,
â™¦ mais la commande interne Â«setÂ»Â liste TOUTES les variables & procÃ©dures ;

â™¦ c'est Â«aliasÂ»Â qui liste les alias dÃ©finis ...
â€¢ unalias


â— contourner les alias de BASH :
par exemple pour Â«grepÂ» :
	/usr/bin/grep
	$(which grep)
	\grep
	"grep" ou 'grep'
	command grep


â— dÃ©claration de variables via Â«declareÂ» :
â€¢ au sein d'une fÂ° elles sont locales par dÃ©fautÂ (sauf si Â«-gÂ» spÃ©cifiÃ©).
declare -i		â†’	entier
declare -r		â†’	L/S			â‰  readonly, qui crÃ©e des variables globales
"	"	-a		â†’ tbl[]
etc.


â— Ã©valuation arithmÃ©tique entre $(( )) et (( )) :
Il y a D'ABORD le dÃ©veloppement des paramÃ¨tres, ENSUITE l'Ã©valuation arithm'.
Avec
	(( 1 + 1 == 2 ? 1 : $(echo "toujours affichÃ© !") ))
le message sera donc TOUJOURS affichÃ© !

â— CALCUL AVEC $(( )), expr ET bc :
â€¢ATTENTION ! Seul bc affiche les rÃ©sultats en virgule flottante ...
 si on lui ordonne Â« scale=ğ‘› Â» !!! OU si on exÃ©cute Â« bc -l Â» (prÃ©cision : 20)
â€¢ex :
faire la moyenne ligne par lignes de colonnes de nombres, stockÃ©es chacune dans un fichier :
	 { echo scale=2; paste -d+ rÃ©s.* | sed 's/,/./g' | while read ln; do  echo "($ln)/10"; done } | bc
_ paste insÃ¨re des + entre les nombres, pour que ce soit interprÃ©tÃ© comme addition par bc ;
_ et sed remplace les virgules par des points pour que bc comprenne :-( ...



â— Autant que possible, mettre l'argument spÃ©cial Â«--Â»,Â qui indique la fin des
 options d'un programme, entre les options & les noms de fichiers passÃ©s
 en paramÃ¨tres, pour Ã©viter les problÃ¨mes inhÃ©rents aux noms de fichiers
 du genre Â«-rfÂ» passÃ©s Ã  des commandes telles que Â«rmÂ» ...
â€¢ De mÃªme, /s bash, si Â«nullglobÂ» est activÃ©,
 il est plus sÃ»r d'utiliser Â«./*Â» Ã  la place de Â«*Â»,Â pour Ã©viter le mÃªme
 problÃ¨me avec les programmes n'acceptant pas Â«--Â» ...

â€¢	shopt -s nullglob	â†’Â si le glob Â«*Â» ne correspond Ã  aucun fichier,
 il est dÃ©veloppÃ© en chaÃ®ne vide.
â€¢	shopt -s lastpipe	â†’Â la derniÃ¨re commande d'une tuyauterie est exÃ©cutÃ©e
 dans le shell au lieu d'un processus dÃ©diÃ©, SAUF si elle est exÃ©cutÃ©e
 en arriÃ¨re-plan.
â€¢ extglob	â†’Â syntaxe des globs Ã©tendus : [+?*]\(motif(|motif)*\) ...



â— GUILLEMETS & ASSIGNATIONS :
â€¢Les guillemets ne sont pas nÃ©cessaires pourÂ 
les assignations sans "export" ni espace :
	var=f*
	var=$v0
	var=$( commande )
 car le dÃ©coupage en mots et le dÃ©veloppement des chemins n'ont pas lieu.
â€¢ MAIS ils sont nÃ©cesssaires quand il y a des espaces dans la valeur assignÃ©e :
	v=" a b c"		sinon : exÃ©cution de Â«aÂ» avec paramÃ¨tres Â«bÂ» et Â«cÂ»
	var="a b c"		sinon : Â«bÂ» est exÃ©cutÃ© avec en paramÃ¨tre Â«cÂ» et l'envVar
 Â«varÂ» armÃ©e Ã  Â«aÂ»
â€¢ nÃ©cessaires avec la commande Â«exportÂ» :
	export var="a"
â€¢ nÃ©cessaires quand on veut Ã©viter le dÃ©veloppement du tilde :
	var=~/rÃ©p		â†’	var == $HOME/rÃ©p
	var='~/rÃ©p'		â†’	var == ~/rÃ©p



â— expressions rationnelles de BASH :
â€¢ globs, BRE, ERE !
Â  globs : * ?
	 en conjugaison avec les ensembles et intervalles [...] et les listes {...}
  extended globs : activÃ©s par Â«shopt -s extglobÂ»
	?(a|b|c) *(...) +(...) : ces prÃ©fixes ont la mÃªme significatÂ° qu'en tant que
		suffixes ERE
	!(...)	: nÃ©gation de la liste donnÃ©e

â€¢	les comparaisons [[ x =~ ]] utilisent des ERE :
	* . x? x* x+ x{ğ‘›} x{m,ğ‘›} x{ğ‘›,} [:digit:] [:alnum:] ([ 	]|^)   etc. etc.
	Mais aussi \< et \> (dÃ©but/fin de mot), \b, \B
_ pour comparer l'expression rationnelle Ã  la totalitÃ© de la chaÃ®ne cible,
 il faut l'encadrer des mÃ©tacaractÃ¨res dÃ©but/fin de ligne : ^ğ‘›ğ‘›ğ‘›ğ‘›$ ;
 sinon, le test ne fait que rechercher l'ERE au sein de la chaÃ®ne cible.


â— TABLEAUX:
	tbl=(v1 v2 v3 ...)
	tbl2=([0]=v1 [2]=v3 [1]=v2)
	tbl[ğ‘›]=vğ‘›
	echo ${tbl[ğ‘›]}

â€¢ Attention Ã  $IFS lors de l'assignation !

â€¢ ajout d'un nouvel Ã©lÃ©ment Ã  un tableau :
	tbl+=(vğ‘›)
Attention cependant, car si le tableau a Ã©tÃ© RAZ via tbl=, le NULL compte
 comme un premier Ã©lÃ©ment.
Pour dÃ©marrer Ã  l'indice 0 avec un ajout +=,
 il faut rÃ©initialiser le tableau via tbl=() !!!

mais :
	tbl+=ğ‘›	â†’	concatÃ¨ne ğ‘› Ã  tbl[0]
	tbl[3]+='aa' concatÃ¨ne 'aa' Ã  tbl[3]

â€¢ taille d'un tableau :	${#tbl[@]}
â€¢ accÃ¨s au dernier indice d'un tableau :	${tbl[-1]} !

â€¢ cf man bash, section Â«TableauxÂ» !

â— traitement d'un tableau en masse :
		tblRes=(  "${tblSrc[@]//de/vers}"  )
Le traitement de "${tbl[@]}" est similaire Ã  celui de "$@" :
 chaque Ã©lÃ©ment du tableau sera fournit protÃ©gÃ© de guillemets, aprÃ¨s
 modification Ã©ventuelle â€“ ici par Â«//Â».

â€¢ ce bout de code :
	liste=â€¢${tbl/%''/â€¢, â€¢}			#remplacement de suffixe
	echo "liste : ${liste%, â€¢}"		#suppression de suffixe
affiche tt les Ã©lÃ©ments du tableau encadrÃ©s de petits disques et sÃ©parÃ©s par
 des virgules. Jouer des modificateurs de variable /% et /# !


â— remplacer wc -w avec un tableau (en particulier s'il faut traiter
 une variable) :
	v=( $ch )
	nbMots=${#v[@]}
â— et ${#var} pour connaitre la longueur de $v !


â— printf est une commande interne !
et le format s'applique Ã  tout les arguments suivant :
	printf 'Â«%sÂ» ' "${tbl[@]}"
affiche tt les Ã©lÃ©ments du tableau encadrÃ©s de guillemets.


â— IFS= ou IFS=$'\n' : INDISPENSABLE quand on traite une liste de noms
 de fichiers (Â«ls -1 | while read -r ...Â») & que l'un d'eux commenÃ§e ou finit
 par un espace ou une tabulation (Ã©liminÃ©s par bash Ã  la lecture
 de la variable !)
â€¢CEPENDANT, dans tout shell moderne, on DOIT utiliser la version plus sÃ»reÂ 
	for f in "$rÃ©p"* ...
â€¢ ma syntaxe prÃ©fÃ©rÃ©e pour armer IFS : $'chaine', qui traite
 correctement les codes Ã©chappÃ©s (\t, \n, ...). cf â†“â†“â†“.


â— MUTEXES : avec flock() !


â— CODER CARACTÃˆRES EN HEXA :
 _ sauf pour \00 :
	varA=$'\x1F'
	varB=$'\x127\x1F'
 _ avec \00, il faut utiliser $"" :
	varA=$'\x41'
	varB=$'\x42'
	varC=$varA$"\0"$varB
	echo $varC | od -c	â†’	A   \   0   B  \n
â— ECRIRE UN OU DES CARACTÃˆRES SPÃ‰CIAUX :
	avec $'xxx' :
		$'\n',
		echo $'coucou RetLn\n\nâ†‘ lÃ  !'

â€¢ afficher VALEUR HEXADÃ‰CIMALE D'UN CARACTÃˆRE (par ex. â—) :
	echo -n â— | hexdump


â—Â« seq 1 100 Â» est profitablement remplaÃ§able par Â« {1..100} Â»
 dans les boucles ...
Â  !!! SANS ESPACES !!! (spÃ©cifique Ã  Bash).
MAIS on ne peut pas utiliser de variables dans l'expression.


â— traitement des chaÃ®nes de caractÃ¨res :
 elles travaillent sur des motifs glob (ou extglob si activÃ©) :
	var=/aa/bb/cc/dd/fic; echo ${var#/*/*/*/}
			â†’ affiche Â«dd/ficÂ»
â€¢ conversion en MAJUSCULE & MINUSCULE :
	${var^^}
	${var,,}
â€¢ suppressÂ° du prÃ©fixe aprÃ¨s dÃ©veloppement :
	${var#prÃ©fixe}
	${var##prÃ©fixe}
	#	# â†’ la plus courte correspondance, ## â†’ la plus longue
â€¢ suppressÂ° du suffixe aprÃ¨s dÃ©veloppement :
	${var%suffixe}
	${var%%suffixe}
	#	% â†’ la plus courte, %% â†’ la plus longue

Â  uniquification des slashs dans un chemin â€“ avec extglob :
	${var//+('/')/'/'}
  suppression des slash terminaux :
	merci au gars ayant fourni cette solution en 2 Ã©tapes sur stackOverflow !
	${var%%${var##*[!/]}}	# supprimer un suffixe correspondant au prÃ©fixe
							# terminÃ© par le dernier caractÃ¨re non-slash
ou
	${var%%+('/')}

â€¢ sous-chaÃ®ne dÃ©butant Ã  Â«posÂ» :
	${var:pos}
â€¢ "	"	" de cette longueur :
	${var:pos:longueur}

â€¢ remplace la 1e occurence ('/')  toutes les occurences ('//') de Â«deÂ» par Â«versÂ» :
	${var/de/vers }
	${var//de/vers }
Â 	S'applique Ã©galement sur les Ã©lÃ©ments des tbl indexÃ©s par [*] ou [@] !
	tblRes=( ${tblOrig[*]/de/vers } )


â— Un bashisme utile :
	echo aa{bb,cc} produit	Â« aabb aacc Â»


â— EXTRACTION DE MOTIFS D'UNE CHAÃNE DE CARACTÃˆRES :
â€¢Avec [[ <chaine> =~ <motif> ]] :
		expression de droite == EXPR. RATIONNELLE Ã‰TENDUE Ã‰TENDUE,
 dont chaque membre entre parenthÃ¨ses est renvoyÃ© ds BASH_REMATCH[ğ‘›â‰¥1] :
	ch="/media/rÃ©p1/doss2/caca/rÃ©p3/doss4"
	[[ "$ch" =~ /media/([^/]+/)([^/]*/)..../(.*) ]]
	echo "${BASH_REMATCH[0]} - nÂ°1 : ${BASH_REMATCH[1]} - nÂ°2 :\
		${BASH_REMATCH[2]} - nÂ°3 : ${BASH_REMATCH[3]}"
 affiche
	"/media/rÃ©p1/doss2/caca/rÃ©p3/ - nÂ°1 : rÃ©p1/ - nÂ°2 :  doss2/ - nÂ°3 : rÃ©p3"
 $BASH_REMATCH â†’ toute l'expression concordante (sans les autres parties
 de la chaÃ®ne !)
 ${BASH_REMATCH[ğ‘›]} â†’ la ğ‘›iÃ¨me partie entre parentÃ¨ses (ğ‘› â‰¥1)
â™¦CEPENDANT, il faut utiliser Â«$'\n'Â» en tant que symbole de fin de ligne
Â dans ces expressions rationnelles, pas Â«$Â» ...

â€¢ ${#var}	â†’ 	longueur var


â— EXÃ‰CUTION CONCURRENTIELLE :
	for x in {1..10}; do
		{ cd "rÃ©p$x"; ls *.sqlite; } &
	done
	wait
â†’ Pas de Â«;Â» aprÃ¨s le Â«&Â»
â†’ la commande Â«waitÂ» permet d'attendre que tous les processus-fils s'achÃ¨vent.

â€¢ la COMPARAISON DE CHAÃNES basÃ©e sur une expression rationnelle se fait
 via les doubles crochets :
	par exemple [[ "$f" != *'Qui?'* ]]
ou en employant l'opÃ©rateur =~ pour utiliser des expressions
 rationnelles Ã©tendues.

â€¢ les DOCUMENTS Â«HEREÂ» VERSION 1-LIGNE :
 par exemple,
	commande <<< "texte"
 ou, avec des substitutions :
	var=$( commande <<< "$texte" )
 qui marche aussi.

â€¢ LA REDIRECTION D'ENTRÃ‰E MARCHE BIEN SÃ›R EN LIGNE DE COMMANDE !
	sort << STOP
lira tt les lignes jusqu'au texte STOP ...



â— REDIRECTIONS NOTABLES :
La commande interne Â«execÂ» peut appliquer les redirections Ã  l'interprÃ©teur
 en cours !
	Â« exec &>6 Â» redirige sortie standard & sortie d'erreur de l'interprÃ©teur
	en cours vers le descripteur de fichier nÂ°6 ...
â€¢ &> : redirection des sorties standard et d'erreur simultanÃ©ment.
  d <& s : le descripteur de fichier Â«sÂ», ouvert en lecture, est dupliquÃ©
 dans Â«dÂ»
â€¢ d >& s : "	"	"	"	", ouvert en Ã©criture, est dupliquÃ© dans Â«dÂ».
 â†’ rediriger le descripteur de fichier Â«nÂ» vers l'entrÃ©e standard du
 programme Â«progÂ» :
		Â«progÂ» <& Â«nÂ»
 â†’ rediriger la sortie standard de Â«progÂ» vers le descripteur de fichier Â«nÂ» :
		Â«progÂ» >& Â«nÂ»
â†’ Ã©crire s/ la sortie d'erreur standard : avec Â« >&2 Â» !


â— CAPTURER LA SORTIE D'ERREUR MAIS AFFICHER LA SORTIE STANDARD :
	{ sortieErr=$( commande 2>&1 1>&3 ); } 3>&1; 3>&-
_Â stderr de Â«commandeÂ» est redirigÃ© vers l'ancien stdout, et stdout
 vers le DF nÂ°3,
puis sortieErr capture la sortie-d'erreur-redirigÃ©e-vers-stdin
_Â le DF nÂ°3 de la liste de commandes est redirigÃ© vers stdin
_Â enfin, le DF nÂ°3 est fermÃ©

â€¢ au sein d'une conduite, chaque commande est exÃ©cutÃ©e dans son
 sous-interprÃ©teur, sauf pour la derniÃ¨re si l'option lastpipe est activÃ©e
 ET si elle est en avant-plan.
 Donc,
	var="A"
	commande | while read x
	do
		...
		var="Z"
		...
	done
	echo $var
affichera "A" ! car $var est modifiÃ©e dans le processus-fils.
â†’ utiliser un tuyau nommÃ© ou une substitution de processus :
	commande > $unFIFO
	while read x
	do
		...
	done < $unFIFO


â— TERMINER UNE LISTE DE COMMANDE DÃˆS LA 1Ã¨re ERREUR :
via
	set -o pipefail
et $? donnera alors le code de retour de la commande ayant renvoyÃ© un code â‰  0,
ou 0 en l'absence d'erreur.



â— surveiller un fichier en tÃ¢che de fond :
tail se termine dÃ¨s que le fichier de nom <fic> est supprimÃ© ou dÃ©placÃ©,
 ou si le PID $pid se termine ; grep renvoit 0 dÃ¨s que <motif> est trouvÃ©,
 et le script se termine de lui-mÃªme (enfin, la commande Ã  utiliser dÃ©pends de
 l'Ã©tat du rÃ©glage Â«lastpipeÂ» et de l'exÃ©cution en avant- / arriÃ¨re-plan) ...
	(
		pid=$BASHPID
		tail --follow=name -n+1 --pid=$pid <fic> | {
			grep --line-buffered -q <motif>
			<autres commandes ...>
			#Si j'ai bien pigÃ©, dans cette situation,
			# la derniÃ¨re commande de cette conduite sera TOUJOURS exÃ©cutÃ©e
			# dans son propre processus ?!
			kill $pid
		}
	) &
	... suite du script ...


â— obtenir la VALEUR DE RETOUR D'UN PROCESSUS-FILS ASYNCHRONE :
	commande &		#lancement d'une commande ou d'une fonction ...
	PIDcommande=$! #stocke le PID du dernier processus lanÃ§Ã©
	...
	wait PIDcommande
	ValRet=$?		#Â«waitÂ» fournit la valeur de retour du processus
ou encore
	...
	wait %texte #attendre processus invoquÃ© par Â«texteÂ» (mais Ã§Ã  ne marche
	ValRet=$?	# pas avec les fonctions lanÃ§Ã©es dans des sous-shells !)


