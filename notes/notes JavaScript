â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚â— Rhinoâ”‚ possÃ¨de un dÃ©bogueur intÃ©grÃ© :
â””â”€â”€â”€â”€â”€â”€â”€â”˜
â€¢	java -jar rhino.jar
â€¢	java org.mozilla.javascript.tools.debugger.Main \
				[options] [filename.js] [script-arguments]



â— oÃ¹ placer la balise <script> dans un fichier HTML ?
â€¢La mÃ©thode moderne est de la placer ds l'Ã©lÃ©ment <head> avec une propriÃ©tÃ©s :
â€¢ async :
_Â script exÃ©cutÃ© dÃ¨s son chargement dans un ordre quelconque, ne bloquant pas
 le traitement du HTML
_Â rÃ©servÃ© aux scripts externes
â€¢ defer :
script chargÃ© en //e,
_Â exÃ©cutÃ©s dans l'ordre d'apparition, APRÃˆS le chargement du document,
	mais AVANT l'Ã©ven DOMContentLoaded
â†’ il faut utiliser Â« document.addEventListener('DOMContentLoaded', fÂ°, ...) Â» !



â— exÃ©cuter du code Ã  la frÃ©quence de rafraichissement de l'Ã©cran :
Â  requestAnimationFrame(cbRappel) : peut recevoir une valeur max,
 et doit Ãªtre appelÃ© pour chaque trame â€“ par ex en fin de fÂ° de MÃ J.
 	La cb recoit en param un horodatage epoch ;
   window.performance.now()Â permet d'obtenir un 1er horodatage de rÃ©fÃ©rence.

â€¢Ã  comparer avec window.setTimeOUt().


â— objet Window :
â€¢ Window : la fenÃªtre (ou l'onglet)
â€¢ Window.document : le DOM y Ã©tant contenu.
â€¢ document.defaultView : la Window contenant le DOM.



â— insÃ©rer plusieurs nÅ“uds en une seule fois (pour Ã©viter les rÃ©arrangements
Ã  chaque insertions) :
	frag = new DocumentFragment();
insÃ©rer les nÅ“uds dans Â«fragÂ» via frag.appendChild(), puis l'insÃ©rer dans
 le futur parent des nÅ“uds.
â€¢ insertion d'Ã©lÃ©ments :
	prÃ©fÃ©rer insertAdjacentHTML() Ã  .innerHTML (ne modifie pas les Ã©ventuels Ã©lÃ©ments dÃ©jÃ  prÃ©sents dans le conteneur),
	voire un DOMParser.
â€¢ document.createTextNode(<chaÃ®ne>) ...


â— armer la position d'un Ã©lÃ©ment :
	elem.offsetLeft = ğ‘›
	elem.offsetTop = ğ‘›
et non elem.style.{top,left} = ğ‘› !



â— PROPRIÃ‰TÃ‰S ET MÃ‰THODES REMARQUABLES :
elem.getBoundingClientRect(),
elem.offsetLeft, elem.offsetTop,

elem.id,
form.action,
...

â€¢elem.classList :
	elem.classList.add()/remove()
	elem.classList.toggle(anc,nouv)
				  .contains()
				  .replace()

â€¢elem.setAttribute(),
â€¢elem.style.removeProperty()/setProperty(), ...


â€¢ window.innerHeight
		.innerWidth
â€¢ window.prompt(texte, valeurRÃ©ponseParDÃ©faut)
		.scrollTo(x,y)
		.scrollBy(Î”x, Î”y)
â€¢ window.open( URL [, '_blank'|'_parent'|'_self'|'_top'|NOMFEN] [, options] )


â€¢Ã©venements souris :
ev.button	â†’ 0 = bouton principal, 1 = molette/milieu, 2 = b. droit,
				3 et 4 = prÃ©cÃ©dent / suivant

â€¢ :
document.getElementById(),
		.getElementsByName(),
		.getElementsByTagName(),
		.querySelector(),		â†’ 1er Ã©lÃ©m rencontrÃ©
		.querySelectorAll(),	â†’ TOUT les Ã©lÃ©ments

document.getElementsByTagName('main')[0].children


â— listes notables du DOM :
document.forms[]
formElem.elements[]
elem.classList[]
elem.chilNodes[]

â— element :
elem.children[],
	.firstChild,
	.lastChild

â€¢ elem.children[] â‰  elem.childNodes[] !
.childNodes :
	propriÃ©tÃ© d'un nÅ“ud du DOM â€“ Â«NodeÂ». Contient tout les nÅ“uds fils
 ( TextNode, Ã©lÃ©ments, commentaires, ...).
.children :
	propriÃ©tÃ© d'un Ã©lÃ©ment â€“ Â«ElementÂ». Contient uniquement les Ã©lÃ©ments fils.

â€¢ elem.setAttribute() â‰  elem.style.setProperty() !

elem.getAttributes()
	.appendChild()
	.prependChild()
	.removeChild()
etc.


â— attributs de donnÃ©es :
dÃ©finits comme les autres attributs HTML
â€“ Leurs noms dÃ©marrent par Â«data-Â»
â€“ accessibles par :
	element.getAttribute(data-xxxx)
	element.dataset.xxx


â— VARIABLES CSS :
_ Si armÃ©e via elem.style.setProperty(),
 rÃ©cupÃ©rables via elem.style.getProperty()
â€¢ via getComputedStyle :
	getComputedStyle(elem,null).getPropertyValue('--var');


â— AJOUTER/SUPPRIMER UN SÃ‰LECTEUR CSS :
	var css = document.createElement("style");
	css.type = "text/css";
	css.innerHTML = "strong { color: red }";
	document.body.appendChild(css);
â€¢ ou, si on est sÃ»r d'avoir une feuille de style :
	var sheet = window.document.styleSheets[0];
	sheet.insertRule('strong { color: red; }', sheet.cssRules.length);


â— en HTML < 5, Il fallait :
â€¢ InsÃ©rer <meta http-equiv="Content-Script-Type" content="text/javascript" />
dans l'entÃªte pour Ã©viter d'indiquer le type de script Ã  chaque dÃ©claration
 d'action, comme dans
	<body onload="javascript: document.forms[0].texte.focus(); testAccesG;">
ou dans
	<script language="javascript">


â— elem.addEventListener(ev, foncÂ° ) :
	pour bloquer l'action par dÃ©faut / la propagation de l'Ã©ven par bullage :
	 foncÂ° doit appeler ev.preventDefault()



â— LA VALEUR DE RETOUR D'UN GESTIONNAIRE D'Ã‰VÃ‰NEMENT joue un rÃ´le :
â€¢Si le gestionnaire renvoit Â«FAUXÂ»Â l'action par dÃ©faut n'est pas exÃ©cutÃ©e
â€¢s'il renvoit Â«VRAIÂ» (ou ne renvoit rien),Â 
	l'action par dÃ©faut sera exÃ©cutÃ© ensuite !

â€¢ <form action="[URL|javascript:fonc()]"> ou form.onsubmit="" :
	de mÃªme que â†‘, la fÂ° doit renvoyer un boolÃ©en indiquant s'il faut ou non
 envoyer le formulaireÂ (Ã  l'addresse spÃ©cifiÃ©e, par la mÃ©thode indiquÃ©e ...)



â— ATTENTIONS AUX PORTÃ‰ES quand on arme un gestionnaire d'Ã©vÃ¨nement ds une bcl !
	for ( x = 0;  x < l;  x++ )
	{
		elem.onclick = function() { fonc(x) }
	}
â†’ Â«foncÂ» est liÃ©e Ã  la portÃ©e du bloc "for..." â€“ donc TOUTES les instances
liÃ©es Ã  onclick verront le MÃŠME x â€“ et sa derniÃ¨re valeur stockÃ©e, celle de l !
â†’ utiliser une closure :
remplacer le corps de la boucle par un appel de fonction, tel que :
	for (x = 0;  x < l;  x++ )
		modifieOnclick( elem, x );


â— AJAX :
	via l'objet XMLHttpRequest
â†’ simple requÃªte GET, POST, ... dirigÃ©e vers le serveur,
  qui renvoit une rÃ©ponse (en HTML, XML, JSON, ...)
â†’ requÃªte asynchrone


---------------------------------- PUR JAVASCRIPT -----------------------------

â— (ES6) patron de chaÃ®ne :
â€¢ avec le guillement inverse.
pour gÃ©nÃ©rer une chaÃ®ne incluant des variables :
	v1 = 'chat';
	v2 = 'mammifÃ¨re';
	res = `le ${v1} est un ${v2}`;


â— boucles Â«for ofÂ» et Â«for inÂ» :
â€¢ Â« for ( v of tbl )Â» :
	parcourt les valeurs ; i reÃ§oit une copie de la valeur
â€¢ Â« for ( p in obj )Â» :
	parcourt les propriÃ©tÃ©s
	â†’ on accÃ¨de Ã  la valeur via Â« obj[i] Â» ...

â— pour toutes les boucles Â«forÂ» :
prÃ©fÃ©rer for (const ...) Ã  for( let ... ) quand on ne modifie pas le compteur !


â€¢ pr savoir si un objet X possÃ¨de la propriÃ©tÃ© Y :
Â« if ( Y in X ) Â»
  ...
â‰  Â« if ( X.hasOwnProperty(Y) ) Â»,
 qui teste si Y est une propriÃ©tÃ© personnelle de X == PAS une propriÃ©tÃ©
 hÃ©ritÃ©e du prototype.
â‰  Â« if ( X.Y ) Â»
 qui teste si la propriÃ©tÃ© est VRAIE, NON-NULLE, ... â†’ renvoit Â«FAUXÂ»
 s'il s'agit d'une chaÃ®ne vide ("") !

â€¢ propriÃ©tÃ© personnelle d'un objet â†’ propriÃ©tÃ© hÃ©ritÃ©e par ses descendants,
 de valeur partagÃ©e par tte les instances des descendants,
 sauf si une de ces instances arme la valeur de cette propriÃ©tÃ©
 â†’ nouvelle propriÃ©tÃ© personnelle de mÃªme nom !

â€¢ les opÃ©rateurs ===, !== ne sont pas ==, !=   !

â— FONCTION AVEC UN NOMBRE VARIABLE D'ARGUMENTS :
Comme on peut appeler une fÂ° avec un nombre indÃ©fini de paramÃ¨tres, on peut
 utiliser l'objet Â«argumentsÂ» :
	fonc() {
		for (let i = 0; i < arguments.length; i++)
			...;
	}
_ Â«argumentsÂ» n'est pas disponible dans les fonctions flÃ©chÃ©es.

â€¢en ES6, il y a les paramÃ¨tres de reste (Â«rest parameterÂ») :
	fonc(a, b, ...args) {		â†’	args sera un tableau
		//rÃ©utilise les mÃªmes paramÃ¨tres â€“ ici sans a et b
		otherFunc(...args);
		//chaque Ã©lÃ©ment du tableau est accessible
		fonc2(args[0], args[1]);

	}
_ le paramÃ¨tre de reste est aussi dÃ©composable en variables distinctes :
	fonc(...[a, b, c] )
â†’ les 3 premiers paramÃ¨tres sont nommÃ©s et accessibles â€“ mais pas les suivants !


â— FONCTIONS FLÃ‰CHÃ‰ES (ARROW FUNCTIONS) â€“ ES6 :
- pas d'objet Â«argumentsÂ»
- le Â«thisÂ» sera celui du contexte de dÃ©claration
- ne peuvent servir de constructeur
- ne peut utiliser Â«yieldÂ»
â€¢ attention Ã  la syntaxe :
â€“ renvoyer un objet :
	a => ( {val: a} )
Les parenthÃ¨ses Ã©vitent l'interprÃ©tation des accolades comme bloc de code.
â€“ armer une variable Ã  une fonction si cette variable est nulle :
	var = var || fonc() {};
	var = var || ( () => {} );	//nÃ©cessite des parentÃ¨ses englobantes !
â€¢ dÃ©composition des variables et valeurs par dÃ©faut :
	fonc = ( [a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;


â— UN EXEMPLE DE SYNTAXE TORDUE MAIS LÃ‰GALE :
findMissingLetter= (a) => (
		s = 'harCode',
		t = 'map',
		n = a[t]( c => c['c'+s+'At']() ), //== c[charCodeAt]() == c.charCodeAt()
		m = Math.min(...n),
		String['fromC'+s]( m + n[t]( n => n-m ).reduce( (x,n,i) => x^n^(1+i),
														0
													  )
						 )
)

----------------------------------------JQuery----------------------------------

â— jquery notable :
â€¢ animations :
	.smoothScroll()
	.hide()/.show()

	.prop(propriÃ©tÃ©, valeur) â† prop' d'un Ã©lÃ©ment html


â€¢ tester si une option particuliÃ¨re a Ã©tÃ© choisie dans un Ã©lÃ©ment <select> :
On ne peut pas faire confiance Ã  la propriÃ©tÃ© Â«valueÂ» quand la liste d' <option>
 est gÃ©nÃ©rÃ©e Ã  partir de sources variables ...
Donc on peut attribuer un id Ã  l'<option> :
	if ( 'id-attendu' == $('#id-du-select option:selected').attr('id') ) {...}

â€¢ jouer sur la visibilitÃ© d'une modale boostrap :
	$('#id-modale').modal(['hide'|'show'|'toggle']);


â€¢AJAX :
_ requÃªte GET :
provoquÃ© par l'emploi d'une fÂ° en 2e param'
	$('...').load('page.html', function {
		... modifications de code ...
	});

_ et POST :
provoquÃ© par l'emploi d'un tableau de valeurs Ã  passer en paramÃ¨tres au POST
	$('...').load(url, [ param1: 'val1', param2: 'val2' ] );

â€¢ les mÃ©thodes $.ajax(), $.get() et $.post() acceptent toutes j'ajout de
 callbacks supplÃ©mentaires :
	$post( url, donnÃ©es, function(datas, status) {
		...
	}).done( function() {
		...
	}).fail( function() {
		...
	}).always( function() {
		...
	});

â€¢ AJAX avancÃ© :
	$.get('page.html', function(dataToInsert) {
		$('...').html(dataToInsert);
	});

	$.post('page.html', function(dataToInsert) {
		$('...').html(dataToInsert);
	});

	$.javax(url, options)
		â†’ la mÃ©thode la plus avancÃ©e mais la moins simple Ã  utiliser

