â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚â— Rhinoâ”‚ possÃ¨de un dÃ©bogueur intÃ©grÃ© :
â””â”€â”€â”€â”€â”€â”€â”€â”˜
â€¢	java -jar rhino.jar
â€¢	java org.mozilla.javascript.tools.debugger.Main \
				[options] [filename.js] [script-arguments]



â— oÃ¹ placer la balise <script> dans un fichier HTML ?
â€¢La mÃ©thode moderne est de la placer ds l'Ã©lÃ©ment <head> avec une propriÃ©tÃ©s :
â€¢ async :
_Â script exÃ©cutÃ© dÃ¨s son chargement dans un ordre quelconque, ne bloquant pas
 le traitement du HTML
_Â rÃ©servÃ© aux scripts externes
â€¢ defer :
script chargÃ© en //e,
_Â exÃ©cutÃ©s dans l'ordre d'apparition, APRÃˆS le chargement du document,
	mais AVANT l'Ã©ven DOMContentLoaded
â†’ il faut utiliser Â« document.addEventListener('DOMContentLoaded', fÂ°, ...) Â» !

â€¢ attention Ã  la combinaison async + addEventListener('DOMContentLoaded') :
l'Ã©venement attendu peut Ãªtre lancÃ© AVANT l'appel Ã  addEventListener(), et
dans ce cas la cb ne sera jamais exÃ©cutÃ©e.
â†’ si document.readyState != 'loading', il est trop tard, exÃ©cuter la cb manuellement.
Il **semble** que Â«document.readyStateÂ» ne change pas pendant l'exÃ©cution de JS :
_Â JS est **monothread**,
_Â les rÃ©fÃ©rences des callbacks & blocs de code Ã  exÃ©cuter sont enlistÃ©es dans
 une queue, et chaque code code est exÃ©cutÃ© sÃ©quentiellement.
Â¿ MAIS EST-CE QUE Ã‡A S'APPLIQUE AUSSI Ã€ document.readystate ?

â— exÃ©cuter du code Ã  la frÃ©quence de rafraichissement de l'Ã©cran :
Â  requestAnimationFrame(cbRappel) : peut recevoir une valeur max,
 et doit Ãªtre appelÃ© pour chaque trame â€“ par ex en fin de fÂ° de MÃ J.
 	La cb recoit en param un horodatage epoch ;
Â  window.performance.now()Â permet d'obtenir un 1er horodatage de rÃ©fÃ©rence.

â€¢Ã  comparer avec window.setTimeOUt().


â— objet Window :
l'objet global au sein d'un onglet de navigateur (MAIS Â« global Â» sous node).
â€¢ Window : la fenÃªtre (ou l'onglet)
â€¢ Window.document : le DOM y Ã©tant contenu.
â€¢ document.defaultView : la Window contenant le DOM.



â— insÃ©rer plusieurs nÅ“uds en une seule fois (pour Ã©viter les rÃ©arrangements
Ã  chaque insertions) :
	frag = new DocumentFragment();
insÃ©rer les nÅ“uds dans Â«fragÂ» via frag.appendChild(), puis l'insÃ©rer dans
 le futur parent des nÅ“uds.
â€¢ insertion d'Ã©lÃ©ments :
	prÃ©fÃ©rer insertAdjacentHTML() Ã  .innerHTML (ne modifie pas les Ã©ventuels
 Ã©lÃ©ments dÃ©jÃ  prÃ©sents dans le conteneur),
	voire un DOMParser.
â€¢ document.createTextNode(<chaÃ®ne>) ...


â— supprimer des Ã©lÃ©ments d'une HTMLElementCollection :
getElementsByClassName(), getElementsByTagName(), elem.children, ...
sont de type HTMLCollection :
une collection Â« live Â», dont les manipulations se reflÃ¨tent dans le DOM.
â†’ NE PAS SUPPRIMER DES Ã‰LEMENTS DEPUIS LE DÃ‰BUT DE LA LISTE !
PlutÃ´t supprimer Ã  partir du dernier (utiliser liste.length).


â— armer la position d'un Ã©lÃ©ment :
	elem.offsetLeft = ğ‘›
	elem.offsetTop = ğ‘›
et non elem.style.{top,left} = ğ‘› !



â— PROPRIÃ‰TÃ‰S ET MÃ‰THODES REMARQUABLES :
elem.getBoundingClientRect(),
elem.offsetLeft, elem.offsetTop,

elem.id,
form.action,
...

â€¢elem.classList :
	elem.classList.add()/remove()
	elem.classList.toggle(anc,nouv)
				  .contains()
				  .replace()

â€¢elem.setAttribute(),
â€¢elem.style.removeProperty()/setProperty(), ...


â€¢ window.innerHeight
		.innerWidth
â€¢ window.prompt(texte, valeurRÃ©ponseParDÃ©faut)
		.scrollTo(x,y)
		.scrollBy(Î”x, Î”y)
â€¢ window.open( URL [, '_blank'|'_parent'|'_self'|'_top'|NOMFEN] [, options] )


â€¢Ã©venements souris :
ev.button	â†’ 0 = bouton principal, 1 = molette/milieu, 2 = b. droit,
				3 et 4 = prÃ©cÃ©dent / suivant

â€¢ :
document.getElementById(),
		.getElementsByClassName(),
		.getElementsByName(),	â†’ tt Ã©lÃ©ments d'attribut "name" donnÃ©
		.getElementsByTagName(),
		.querySelector(),		â†’ 1er Ã©lÃ©m rencontrÃ©
		.querySelectorAll(),	â†’ TOUT les Ã©lÃ©ments

document.getElementsByTagName('main')[0].children


â— listes notables du DOM :
document.forms[]
formElem.elements[]
elem.classList[]
elem.chilNodes[]

â— element :
elem.children[],
	.firstChild,
	.lastChild

â€¢ elem.children[] â‰  elem.childNodes[] !
.childNodes :
	propriÃ©tÃ© d'un nÅ“ud du DOM â€“ Â«NodeÂ». Contient tout les nÅ“uds fils
 ( TextNode, Ã©lÃ©ments, commentaires, ...).
.children :
	propriÃ©tÃ© d'un Ã©lÃ©ment â€“ Â«ElementÂ». Contient uniquement les Ã©lÃ©ments fils.

â€¢ elem.setAttribute() â‰  elem.style.setProperty() !

elem.closest('sÃ©lecteur') â€“ renvoit l'Ã©lÃ©ment, un parent, ou null

elem.getAttributes()
	.appendChild()
	.prependChild()
	.removeChild()
etc.


â— ATTRIBUTS DE DONNÃ‰ES :
dÃ©finits comme les autres attributs HTML
â€“ Leurs noms dÃ©marrent par Â«data-Â»
â€“ accessibles par :
	element.getAttribute(data-xxxx)
	element.dataset.xxx


â— VARIABLES CSS :
_ Si armÃ©e via elem.style.setProperty(),
 rÃ©cupÃ©rables via elem.style.getProperty()
â€¢ via getComputedStyle :
	getComputedStyle(elem,null).getPropertyValue('--var');


â— AJOUTER/SUPPRIMER UN SÃ‰LECTEUR CSS :
	var css = document.createElement("style");
	css.type = "text/css";
	css.innerHTML = "strong { color: red }";
	document.body.appendChild(css);
â€¢ ou, si on est sÃ»r d'avoir une feuille de style :
	var sheet = window.document.styleSheets[0];
	sheet.insertRule('strong { color: red; }', sheet.cssRules.length);

â€¢ rÃ©cupÃ©rer une rÃ¨gle CSS :
Cette fonction part du postulat qu'il y a UNE feuille de style (styleSheets[0]).
_ Parcourir Â«document.styleSheets[ğ‘›].cssRulesÂ»,
_  tester la prop Â«selectorTextÂ»
â†’ renvoit une Â«CSSStyleRuleÂ»
    function getStyle(selector)
    {
        const rules = document.styleSheets[0].cssRules;
        const l = rules.length;

        for (let i = 0; i < l; ++i) {
            if (rules[i].selectorText == selector) {
                return rules[i];
            }
        }
        return null;
    }

â€¢ modifier une Â«CSSStyleRuleÂ» :
ex :
	CSSStyleRule.style.display = 'none';
etc.


â— en HTML < 5, Il fallait :
â€¢ InsÃ©rer <meta http-equiv="Content-Script-Type" content="text/javascript" />
dans l'entÃªte pour Ã©viter d'indiquer le type de script Ã  chaque dÃ©claration
 d'action, comme dans
	<body onload="javascript: document.forms[0].texte.focus(); testAccesG;">
ou dans
	<script language="javascript">


â— elem.addEventListener(ev, callback ) / ev.preventDefault() / ev.stopPropagation() :
â€¢ ev.preventDefault() :
	Bloque l'action par dÃ©faut du navigateur, mais pas le bullage de l'Ã©ven.
â€¢ ev.stopPropagation():
	Bloque le bullage â€“ seul l'Ã©lÃ©ment courant effectue des actions en retour,
 pas les Ã©lÃ©ments parents.
â€¢ renvoyer TRUE/FALSE :
	SANS EFFET EN JAVASCRIPT PUR.
	Ã‰quivalent ev.preventDefault() + ev.stopPropagation() sous JQuery.



â— LA VALEUR DE RETOUR D'UN GESTIONNAIRE D'Ã‰VÃ‰NEMENT joue un rÃ´le :
â€¢Si le gestionnaire renvoit Â«FAUXÂ»Â l'action par dÃ©faut n'est pas exÃ©cutÃ©e
â€¢s'il renvoit Â«VRAIÂ» (ou ne renvoit rien),Â 
	l'action par dÃ©faut sera exÃ©cutÃ© ensuite !

â€¢ <form action="[URL|javascript:fonc()]"> ou form.onsubmit="" :
	de mÃªme que â†‘, la fÂ° doit renvoyer un boolÃ©en indiquant s'il faut ou non
 envoyer le formulaireÂ (Ã  l'addresse spÃ©cifiÃ©e, par la mÃ©thode indiquÃ©e ...)


â— PORTÃ‰E DE Â« THIS Â» :
â€¢ dans une simple fonction :
	la portÃ©e globale (l'objet window au sein d'un navigateur)
â€¢ dans une mÃ©thode :
	l'objet conteneur.
	-> Mais ce n'est PAS le cas pour une fonction dans une mÃ©thode !
â€¢ dans une fonction flÃ©chÃ©e :
	le contexte dans lequel elle est dÃ©clarÃ©e
â€¢ APPELER UNE FONCTION DANS UN CONTEXTE BIEN DÃ‰FINI :
	var agent = {
		name: 'bla';
		action: function(callback) {
			callback.call(this);
		}
	}

	// cette fonction est dans le contexte de Â« Window Â»
	function do() {
		console.log( ... + this.name );
	}
	agent.action(do);

-> la callback sera appelÃ©e par Â« .call() Â» dans le contexte de l'objet.

â€¢ fonc.call(this, arg1, arg2, arg3, ...)        -> liste d'arguments
  fonc.apply(this, [arg1, arg2, arg3, ...] )    -> un tableau d'arguments



â— ATTENTIONS AUX PORTÃ‰ES quand on arme un gestionnaire d'Ã©vÃ¨nement ds une bcl !
	for ( x = 0;  x < l;  x++ )
	{
		elem.onclick = function() { fonc(x) }
	}
â†’ Â«foncÂ» est liÃ©e Ã  la portÃ©e du bloc "for..." â€“ donc TOUTES les instances
liÃ©es Ã  onclick verront le MÃŠME x â€“ et sa derniÃ¨re valeur stockÃ©e, celle de l !
â†’ utiliser une closure :
remplacer le corps de la boucle par un appel de fonction, tel que :
	for (x = 0;  x < l;  x++ )
		modifieOnclick( elem, x );


â— AJAX :
	via l'objet XMLHttpRequest
â†’ simple requÃªte GET, POST, ... dirigÃ©e vers le serveur,
  qui renvoit une rÃ©ponse (en HTML, XML, JSON, ...)
â†’ requÃªte asynchrone

JSON.stringify(obj) â†’ chaÃ®ne JSON. les propriÃ©tÃ©s indÃ©finies sont Ã©cartÃ©es.
JSON.parse(ch)      â†’ objet



â— afficher le contenu d'un objet via console.log() :
utiliser des virgules pour SÃ‰PARER LES PARAMÃˆTRES
 â†’ le navigateur affichera l'objet de maniÃ¨re dÃ©taillÃ©e.
	console.log("texte", obj)


---------------------------------- PUR JAVASCRIPT -----------------------------

â— (ES6) PATRON DE CHAÃNE avec le guillemet inverse.
pour gÃ©nÃ©rer une chaÃ®ne incluant des variables :
	v1 = 'chat';
	v2 = 'mammifÃ¨re';
	res = `le ${v1} est un ${v2}`;


â— conversion implicite en nombre via le prÃ©fixe Â« + Â» :
val = +'1234'
val = +'blabla' â†’    NaN !



â— BOUCLES Â«FOR OFÂ» (VALEURS) ET Â«FOR INÂ» (INDEXES) :
â€¢ VALEUR â€“ Â« for ( v of tbl )Â» :
	parcourt les valeurs ; i reÃ§oit une copie de la valeur
â€¢ INDICES â€“ Â« for ( p in obj )Â» :
	parcourt les propriÃ©tÃ©s, (donc les indices pour un tableau)
	â†’ on accÃ¨de Ã  la valeur via Â« obj[p] Â» ...

â€¢ tbl.forEach( (val [, index [, array]] ) => ... )


â— pour toutes les boucles Â«forÂ» :
prÃ©fÃ©rer for (const ...) Ã  for( let ... ) quand on ne modifie pas le compteur !



â— HOISTING :
_ Â«varÂ» est sujet au hoisting,
_ PAS Â«letÂ» et Â«constÂ».


â€¢ prÃ©fixes numÃ©riques :
  0x...     hexa
  0b...     binaire
  0o...     octal


â— TYPES DE BASE :
	Undefined
	Null
	Boolean
	Number
	String
	Object
	Symbol (depuis ES6)

â€¢ falsy :
	undefined
	null
	false
	0
	chaÃ®ne vide ''
	tableau vide [], objet vide {} SAUF SI CONVERSION EN BOOLÃ‰EN
	NaN

â€¢ truthy :
	tout le reste ! chaÃ®nes, tableaux et objets ayant contenu ...

â€¢ le cas particulier des tableaux vides :
	let tbl = [];
	( tbl == false ) -> true
	Boolean(tbl)     -> true
Un tableau vide est falsy par dÃ©faut,
 SAUF en cas de conversion explicite par Â« Boolean(tbl) Â»
 ou par la nÃ©gation Â« !tbl Â»


â—  typeof() et instanceof ... :
	if ( typeof(obj) == 'String' )
		...
	if ( obj instanceof MonObjet )
		...


â€¢ pr savoir si un objet X possÃ¨de la propriÃ©tÃ© Y :
Â« if ( Y in X ) Â»
  ...
â‰  Â« if ( X.hasOwnProperty(Y) ) Â»,
 qui teste si Y est une propriÃ©tÃ© personnelle de X == PAS une propriÃ©tÃ©
 hÃ©ritÃ©e du prototype.
â‰  Â« if ( X.Y ) Â»
 qui teste si la propriÃ©tÃ© est VRAIE, NON-NULLE, ... â†’ renvoit Â«FAUXÂ»
 s'il s'agit d'une chaÃ®ne vide ("") !

â€¢ propriÃ©tÃ© personnelle d'un objet â†’ propriÃ©tÃ© hÃ©ritÃ©e par ses descendants,
 de valeur partagÃ©e par tte les instances des descendants,
 sauf si une de ces instances arme la valeur de cette propriÃ©tÃ©
 â†’ nouvelle propriÃ©tÃ© personnelle de mÃªme nom !

â€¢ les opÃ©rateurs ===, !== ne sont pas ==, !=   !

â€¢ raccourci pour assigner une valeur par dÃ©faut :
	var = val || defaultVal;



MÃ‰THODES ET FONCTIONS NOTABLES DES OBJETS :
â€¢supprimer une propriÃ©tÃ© :
	delete( obj.prop )
â€¢ avant stringification, on peut aussi utiliser
	obj.prop = undefined
car les propriÃ©tÃ©s indÃ©finies ne sont pas converties ...

Â« obj.prop = fÂ° flÃ©chÃ©e Â» est possible ...



â— MÃ‰THODES NOTABLES DES TABLEAUX :
â€¢ la seule diffÃ©rence visible entre un tableau et un autre type d'objet, c'est
		.length

tbl.map( v => f(v) )
	â†’ tableau de mÃªme taille
tbl.filter( v => testBoolÃ©en )
	â†’ tableau ne contenant que les valeurs rÃ©pondant au critÃ¨re
tbl.reduce( (accum, v) => accum + v, v0DeAccum )
	â†’ opÃ©ration cyclique sur toutes les entrÃ©es du tableau

_ fin du tableau :
	tbl.push()
	tbl.pop()



â— FONCTION VARIADIQUE (avec un nombre variable d'arguments) :
Comme on peut appeler une fÂ° avec un nombre indÃ©fini de paramÃ¨tres, on peut
 utiliser l'objet Â«argumentsÂ» :
	fonc() {
		for (let i = 0; i < arguments.length; i++)
			...;
	}
_ Â«argumentsÂ» n'est pas disponible dans les fonctions flÃ©chÃ©es.

â€¢ en ES6, il y a les paramÃ¨tres de reste (Â«rest parameterÂ») :
le paramÃ¨tre de reste est un TABLEAU
	fonc(a, b, ...args) {		#â†’	args sera un tableau
		//rÃ©utilise les mÃªmes paramÃ¨tres â€“ ici sans a et b
		otherFunc(...args);
		if (args.length > 0) {
			//chaque Ã©lÃ©ment du tableau est accessible
			fonc2(args[0], args[1]);
		}
	}
_ le paramÃ¨tre de reste est aussi dÃ©composable en variables distinctes :
	fonc(...[a, b, c] )
â†’ les 3 premiers paramÃ¨tres sont nommÃ©s et accessibles â€“ mais pas les suivants !


â€¢ OPÃ‰RATEUR DE DESTRUCTURATION / Â« SPREAD Â» :
	tbl = [a, b]
	function f(p1, p2) {... }

	f(...tbl)     // le tableau est dÃ©composÃ© en son contenu

	biggerTbl = [ ...tbl, x, y ]    // biggerTbl dÃ©bute par le contenu de tbl

	var obj1 = {ch1: 1; ch2: 2}  //les propriÃ©tÃ©s de obj1 sont copiÃ©es dans obj2
	obj2 = { ...obj1, ch3: 3, ch4: 4 }

â€¢ ASSIGNATION DÃ‰STRUCTURANTE :
	let a, b,
		allTheRest;
	[ a, b ] = [v1, v2];
		# â†’ a = v1,
		#   a = v2
	[ a, b, ...allTheRest] = [1, 2, 4, 8, 16];
		# â†’ a = 1,
		#   b = 2,
		#   allTheRest = [4, 8, 16];



â— FONCTIONS FLÃ‰CHÃ‰ES (ARROW FUNCTIONS) â€“ ES6 :
	const fonc = (a,b) => a + b;
	const fonc = (name) => { console.log(name) }
	[12, 14, 25, 13].filter( age => age < 18 )

- pas d'objet Â«argumentsÂ»
- le Â«thisÂ» est celui du contexte de dÃ©claration
- ne peuvent servir de constructeur
- ne peut utiliser Â«yieldÂ»

â€¢ attention Ã  la syntaxe :
â€“ RENVOYER UN OBJET :
Les parenthÃ¨ses Ã©vitent l'interprÃ©tation des accolades comme bloc de code.
	a => ( {val: a} )
_ reprendre une variable d'entrÃ©e dans la construction d'un objet crÃ©Ã©
 UN CHAMPS DE MÃŠME NOM ET VALEUR :
	value => ({ value, double: a*2 })

â€¢ armer une variable Ã  une fonction SSI cette variable est nulle :
	var = var || fonc() {};
	var = var || ( () => {} );	//nÃ©cessite des parentÃ¨ses englobantes !

â€¢ dÃ©composition des variables et valeurs par dÃ©faut :
	fonc = (  a, b,         ,     c              )  => ...
	fonc = ( [a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;



â— UN EXEMPLE DE SYNTAXE TORDUE MAIS LÃ‰GALE :
findMissingLetter= (a) => (
		s = 'harCode',
		t = 'map',
		n = a[t]( c => c['c'+s+'At']() ), //== c[charCodeAt]() == c.charCodeAt()
		m = Math.min(...n),
		String['fromC'+s]( m + n[t]( n => n-m ).reduce( (x,n,i) => x^n^(1+i),
														0
													  )
						 )
)



â— MODULES ES6 :
	import * from './nomFichierSansPointJs';
	import symbol from './nomSansPointJs';

un peu comme les IIFE ...

----------------------------------------JQuery----------------------------------

â— jquery notable :
â€¢ animations :
	.smoothScroll()
	.hide()/.show()

	.prop(propriÃ©tÃ©, valeur) â† prop' d'un Ã©lÃ©ment html


â€¢ tester si une option particuliÃ¨re a Ã©tÃ© choisie dans un Ã©lÃ©ment <select> :
On ne peut pas faire confiance Ã  la propriÃ©tÃ© Â«valueÂ» quand la liste d' <option>
 est gÃ©nÃ©rÃ©e Ã  partir de sources variables ...
Donc on peut attribuer un id Ã  l'<option> :
	if ( 'id-attendu' == $('#id-du-select option:selected').attr('id') ) {...}

â€¢ jouer sur la visibilitÃ© d'une modale boostrap :
	$('#id-modale').modal(['hide'|'show'|'toggle']);


â€¢AJAX :
_ requÃªte GET :
provoquÃ© par l'emploi d'une fÂ° en 2e param'
	$('...').load('page.html', function {
		... modifications de code ...
	});

_ et POST :
provoquÃ© par l'emploi d'un tableau de valeurs Ã  passer en paramÃ¨tres au POST
	$('...').load(url, [ param1: 'val1', param2: 'val2' ] );

â€¢ les mÃ©thodes $.ajax(), $.get() et $.post() acceptent toutes j'ajout de
 callbacks supplÃ©mentaires :
	$post( url, donnÃ©es, function(datas, status) {
		...
	}).done( function() {
		...
	}).fail( function() {
		...
	}).always( function() {
		...
	});

â€¢ AJAX avancÃ© :
	$.get('page.html', function(dataToInsert) {
		$('...').html(dataToInsert);
	});

	$.post('page.html', function(dataToInsert) {
		$('...').html(dataToInsert);
	});

	$.javax(url, options)
		â†’ la mÃ©thode la plus avancÃ©e mais la moins simple Ã  utiliser


â— plugins jquery d'intÃ©rÃªt:
	dataTable   - affichage de tableau triable, recherchable, Ã©ditable


â€¢ calendrier avancÃ© :
	fullCalendar    - affichage d'Ã©vÃ©nement, etc.

