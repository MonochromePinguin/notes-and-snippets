â— une 20aine de frameworks java regroupÃ©s.

ce(s) framework(s) permettent de gÃ©rer parallÃ©lisme, load-balancing, ...

â€¢ histoire :
_ 2002 : Rd Johnson publie Â«Â Expert One-on-One J2EE Desing & Development Â», contenant
du code et un diagramme de classe ...
_ 2004 : ... devenu String 1.0


â€¢ contraintes mÃ©tier,
â€¢ contraintes techniques :
    parallÃ©lisme,
    temps de rÃ©ponse (systÃ¨mes temps-rÃ©el),
    haute disponibilitÃ© 
        â†’ on peut p.ex utiliser la rÃ©plication : ğ‘› instances en load-balancing.
â€¢ contraintes pratiques :
    _ Ã©volutivitÃ©,
    _ maintenabilitÃ©,
    _ O de SOLID (possibilitÃ© d'insÃ©rer des greffons)
    _ portabilitÃ© (parfois),
    _ interopÃ©rabilitÃ© :
        
â— RMI : Â« Remote Method Invocation Â» :
    API java pour le RPC au sein d'une architecture rÃ©partie en JAVA.
    registre central/ annuaire,

â—    fichier .wsdl (Web Service Description Language, dÃ©rivÃ© du XML),
    Ã©changes via SOAP

â— Spring :
_ framework basÃ© sur l'IOD.
_ un .xml ou des annotations indiquent les classes Ã  instancier pour injection.
_ architecture AOP â€“ Â« Aspect Oriented Programming Â»



â— PLUSIEURS APPROCHES POUR L'INJECTION DE DÃ‰PENDANCES :
_ injection via un setter, convention java beans
_ via le constructeur, comme sous symfony
â€¢ injection directe dans la propriÃ©tÃ© *privÃ©e* par spring, via dÃ©finition
dans la config .xml ( <property name="champ" value="val"/> ) 
_ Cette mÃ©thode est utilisable pour toute propriÃ©tÃ©, de type simple ou non :
    int, String, List, Set, Map, mais aussi fichier ...
    <bean id="testBean" class="com.monochrome.test">
        <property name="list">
            <list>
                <value>....</value>
                <value>....</value>
            </list>
        </property>
        <property name="intProp" value="43"/>
        <property name="injectedVariable" value=${name.space.of.value} />
    </bean>
_ les Â«Â inner beans Â» : beans injectÃ©s dans un bean :
    ...
        <property name="innerBean">
            <bean id="..." class="...">
                ...
            </bean>
        </property>
    ...

â€¢ org.spring.applicationContext : conteneur de l'application, responsable de l'injection.



â— BEANS :
_ trouvÃ©s par XML, injection, ou code java
_ annotÃ©s @Component
    ou @Component("autreNom")

 
â— PORTÃ‰ES DES BEAN ( @scope(<portÃ©es>) ) :
â€¢ singleton (par dÃ©faut) :
    1 seule instance par ApplicationContext
â€¢ prototype :
    nouvelle instance Ã  chaque requÃªte de Bean

(â†“ portÃ©es spÃ©cifiques aux app' web : )
â€¢ request(proxyMode = ScopedProxyMode.TARGET_CLASS) :
    une instance pour chaque requÃªte HTTP.
    Le paramÃ¨tre Â«proxyModeÂ» serait nÃ©cessaire ??????? 
â€¢ session(proxyMode = ScopedProxyMode.TARGET_CLASS) :
    ... chaque session de client HTTP
â€¢ application :
    la durÃ©e de vie de la servlet
â€¢ webSocket :
    ...
â€¢ flow :
    la durÃ©e de vie d'un Â«flowÂ» â€“ un programme s'exÃ©cutant pour le compte d'un
    client HTTP : ???? session ? requÃªte ?



â— PROXYS DE BEAN :
C'est de l'AOP â€“ Â« Aspect Oriented Programming Â»
    Pour injecter un bean dans un autre de portÃ©e diffÃ©rente (p.ex un bean 
de portÃ©e Â«requestÂ» injectÃ© dans un bean de portÃ©e Â«singletonÂ»),
 et garder l'intÃ©gritÃ© de rÃ©fÃ©rence, on injecte un proxy :
â†’ configuration spÃ©ciale du bean :
â€¢ en XML :
    <bean id="unId" class="com.monochrome.Class" scope="session">
        <aop:scoped-proxy>
    </bean>
â€¢ annotation :
    ???????????
    
    
â— CYCLE DE VIE D'UN BEAN :
Ne pas utiliser le constructeur, qui est appelÃ© avant l'hydratation du bean ..
â€¢ propriÃ©tÃ©s XML :
    <bean id="leBean" init-method = "initFonc" destroy-method="destroyFonc">
    </bean>
â€¢ annotations (officiellement recommandÃ© !) :
    ????
    @Pre-destroy
â€¢ implÃ©mentation d'interface :
    ????


â— ANNOTATIONS NOTABLES :
@Repository,
@Service,
@Controller


â— SECTIONS CRITIQUES :
_ @Transactional :
    cette annotation sur une mÃ©thode permet l'exclusion mutuelle entre threads


