â— une 20aine de frameworks java regroupÃ©s.

ce(s) framework(s) permettent de gÃ©rer parallÃ©lisme, load-balancing, ...

â€¢ histoire :
_ 2002 : Rd Johnson publie Â«Â Expert One-on-One J2EE Desing & Development Â», contenant
du code et un diagramme de classe ...
_ 2004 : ... devenu String 1.0


â€¢ contraintes mÃ©tier,
â€¢ contraintes techniques :
	parallÃ©lisme,
	temps de rÃ©ponse (systÃ¨mes temps-rÃ©el),
	haute disponibilitÃ©
		â†’ on peut p.ex utiliser la rÃ©plication : ğ‘› instances en load-balancing.
â€¢ contraintes pratiques :
	_ Ã©volutivitÃ©,
	_ maintenabilitÃ©,
	_ O de SOLID (possibilitÃ© d'insÃ©rer des greffons)
	_ portabilitÃ© (parfois),
	_ interopÃ©rabilitÃ© :

â— RMI : Â« Remote Method Invocation Â» :
	API java pour le RPC au sein d'une architecture rÃ©partie en JAVA.
	registre central/ annuaire,

â— fichier .wsdl (Web Service Description Language, dÃ©rivÃ© du XML),
	Ã©changes via SOAP

â— Spring :
_ framework basÃ© sur l'IOD.
_ un .xml ou des annotations indiquent les classes Ã  instancier pour injection.
_ architecture AOP â€“ Â« Aspect Oriented Programming Â»



â— PLUSIEURS APPROCHES POUR L'INJECTION DE DÃ‰PENDANCES :
_ injection via un setter, convention java beans
_ via le constructeur, comme sous symfony
â€¢ injection directe dans la propriÃ©tÃ© *privÃ©e* par spring, via dÃ©finition
dans la config .xml ( <property name="champ" value="val"/> )
_ Cette mÃ©thode est utilisable pour toute propriÃ©tÃ©, de type simple ou non :
	int, String, List, Set, Map, mais aussi fichier ...
	<bean id="testBean" class="com.monochrome.test">
		<property name="list">
			<list>
				<value>....</value>
				<value>....</value>
			</list>
		</property>
		<property name="intProp" value="43"/>
		<property name="injectedVariable" value=${name.space.of.value} />
	</bean>
_ les Â«Â inner beans Â» : beans injectÃ©s dans un bean :
	...
		<property name="innerBean">
			<bean id="..." class="...">
				...
			</bean>
		</property>
	...

â€¢ org.spring.applicationContext : conteneur de l'application, responsable de l'injection.



â— BEANS :
_ trouvÃ©s par XML, injection, ou code java
_ annotÃ©s @Component
	ou @Component("autreNom")


â— PORTÃ‰ES DES BEAN ( @scope(<portÃ©es>) ) :
â€¢ singleton (par dÃ©faut) :
	1 seule instance par ApplicationContext
â€¢ prototype :
	nouvelle instance Ã  chaque requÃªte de Bean

(â†“ portÃ©es spÃ©cifiques aux app' web : )
â€¢ request(proxyMode = ScopedProxyMode.TARGET_CLASS) :
	une instance pour chaque requÃªte HTTP.
	Le paramÃ¨tre Â«proxyModeÂ» serait nÃ©cessaire ???????
â€¢ session(proxyMode = ScopedProxyMode.TARGET_CLASS) :
	... chaque session de client HTTP
â€¢ application :
	la durÃ©e de vie de la servlet
â€¢ webSocket :
	...
â€¢ flow :
	la durÃ©e de vie d'un Â«flowÂ» â€“ un programme s'exÃ©cutant pour le compte d'un
	client HTTP : ???? session ? requÃªte ?



â— PROXYS DE BEAN :
C'est de l'AOP â€“ Â« Aspect Oriented Programming Â»
	Pour injecter un bean dans un autre de portÃ©e diffÃ©rente (p.ex un bean
de portÃ©e Â«requestÂ» injectÃ© dans un bean de portÃ©e Â«singletonÂ»),
 et garder l'intÃ©gritÃ© de rÃ©fÃ©rence, on injecte un proxy :
â†’ configuration spÃ©ciale du bean :
â€¢ en XML :
	<bean id="unId" class="com.monochrome.Class" scope="session">
		<aop:scoped-proxy>
	</bean>
â€¢ annotation :
	???????????


â— CYCLE DE VIE D'UN BEAN :
Ne pas utiliser le constructeur, qui est appelÃ© avant l'hydratation du bean ..
â€¢ propriÃ©tÃ©s XML :
	<bean id="leBean" init-method = "initFonc" destroy-method="destroyFonc">
	</bean>
â€¢ annotations (officiellement recommandÃ© !) :
	????
	@Pre-destroy
â€¢ implÃ©mentation d'interface :
	????


â— ANNOTATIONS NOTABLES :
@Repository â†’ ,
@Service,
@Controller

â€¢ mÃ©thode Ã  enrober dans un try{}catch(){} / BEGIN TRANSACTION/COMMIT :
    @Transactional


â— SECTIONS CRITIQUES :
_ @Transactional :
	cette annotation sur une mÃ©thode permet l'exclusion mutuelle entre threads



â— DÃ‰MARRAGE DE SPRING :
Par dÃ©faut, Ã  moins qu'on ai spÃ©cifiÃ© une autre classe de dÃ©marrage dans
le web.xml, spring cherche Ã  dÃ©marrer la servlet Â« DispatcherServlet Â» :
â†’ spring recherche dans WEB-INF/ le fichier de configuration 
    Â« DispatcherServlet-servlet.xml Â»

â€¢ changer la servlet par dÃ©faut de spring â€“ dans web.xml :
Dans la dÃ©claration de servlet
    <servlet>
        ...
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    
    
â— SPRING BOOT : 
â€¢ config centralisÃ©e dans resources/applications.properties :
	spring.datasource.url = jdbc:mysql://localhost:3306/studentProject
	spring.datasource.username = javaStudent
	spring.datasource.password = Turlututu!
	# Keep the connection alive if idle for a long time (needed in production)
	#spring.datasource.testWhileIdle = true
	#spring.datasource.validationQuery = SELECT 1
	spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect

â€¢ classe principale :
	@SpringBootApplication
	//dÃ©finit le ou les packages where @Components should be loaded from
	@ComponentScan(basePackages = "org.monochrome.servlets") 
	public class Main {

		public static void main(String[] args) {
			SpringApplication.run(Main.class, args);
		}
	}

â€¢ dans org.monochrome.servlets :
	@RestController, @Controller
â€¢ pour les entitÃ©s :
	@Entity
	@Table(name="...")
ainsi que
	@Column(name="", nullable="", ...)	
	

conteneur Ã  micro-services.
Chaque micro-service est fourni par une servlet
 de cycle de vie indÃ©pendant des autre.
_ ConfigurationService :
    centralise toutes les configurations, globales et spÃ©cifiques Ã  chaque service.
_ RegistryService :
    sert de dispatcher entre les microservices.
_ JMS Â« Java Messaging Service Â» :
    bus de comm' entre microservices.
    
â€¢

