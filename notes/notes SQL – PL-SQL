‚Ä¢ SQL : standard

‚Ä¢ PL/SQL : ¬´ Procedural Language / Structured Query Language ¬ª
sp√©cifique √† Oracle

_ language avec une notion d'objets
_ structur√© en blocs it√©ratifs

_ nombreuses commandes qu'on ne retrouve pas dans le SQL

_ insensible √† la casse


‚óè SQLPLUS :
‚Ä¢ connexion :
sqlplus						‚Üí	√† la BdD par d√©faut
sqlplus <NOM>@<BdD>
sqlplus <NOM>/<MdP>@<BdD>	moins s√©curis√©


‚Ä¢ ex√©cuter un script :
	@<fichier>
‚Ä¢ et une proc√©dure :
	execute [|<nomPackage>.]<nomProc>

‚Ä¢ les blocs de code doivent SE TERMINER PAR UN SLASH pour √™tre ex√©cut√©s :
si une d√©claration de proc√©dure, package, ... ne se termine pas par un slash,
 sqlplus affichera un prompt d√©butant par un n¬∞ de ligne en attendant + de code.

‚Ä¢ largeur d'affichage des r√©sultats :
	set lin[|esize] <largeur> 

‚Ä¢ d√©finir une variable :
	def var = val
ou
	define var = val
	//l'utilisation de la variable se fait via le pr√©fixe & :
	... &var ...



‚óè conception mod√®le de donn√©es :
¬ø Dans quelle(s) table(s) stocker les donn√©es ?
Quand on a, √† la fois, dans une entit√© :
_ des donn√©es qui varient peu
		(p.ex, pour un film : titre, genres, r√©alisateur, ...),
_ des donn√©es souvent mises √† jour
	 (p.ex pour ce m√™me film : nombre entr√©es r√©alis√©es, ..., mises √† jour
	  toutes les nuit)
‚Üí il vaut mieux stocker les donn√©es ¬´ constantes ¬ª dans un table, et les
 donn√©es variables dans une autre, pour des raisons de performance.


‚Ä¢ analyse d√©cisionnelle :
	des ¬´ faits ¬ª, dans une table centrale, li√©s √† des ¬´ dimensions ¬ª / axes d'analyses 
‚Üí  ut¬∞ de fonctions d'aggr√©gation avec GROUP BY


‚Ä¢ SQL ‚Üí paradigme ensembliste :
	pas d'affectation de variables, de stockage, de boucles, juste manipulation de tables.
‚Ä¢ SQL ‚Üí paradigme imp√©ratif :
	suite d'instruction ; variables, boucles, ...
	
‚Ä¢ Dans l'id√©al, le moins de PL/SQL possible, car le PL/SQL est plus lent que le SQL
‚Üí autant que possible, faire du SQL plut√¥t que du PL/SQL.

================================================================================


‚óè BONNES PRATIQUES :
_ commenter les blocs de code
_ pr√©fixer les variables (v_), constantes (c_), param√®tres (p_), ...
_ lisibilit√© : 
	pr√©f√©rer le nommage des param√®tres lors de l'appel de proc√©dures :
		getDividedNum(p_divider => 3)  

‚Ä¢ PAS de SELECT * : si un coll√®gue rajoute une colonne, √ßa peut p√©ter le PL/SQL ...

‚Ä¢ autant que possible, PAS de LIKE / NOT IN / HAVING / ORDER BY :
	NOT IN : remplacer par NOT EXISTS
	ORDER BY : gourmand en ressources, ne s'en servir que pour l'affichage
				utiliser des fonctions analytiques
‚Ä¢ autant que possible, pas de DISTINCT ‚Äì risque de passer sous silence des donn√©es.

_ les lignes ne sont PAS tri√©es sans ORDER BY, ne pas compter sur un tri particulier

_ diminuer la complexit√© cyclomatique

_ 1er package √† cr√©er au d√©but d'un projet :
un PACKAGE de log, permettant de tracer toutes actions.

‚Ä¢ PAS de TRIGGER : gros risque pour la maintenabilit√©.



‚óè structures :
‚Ä¢ d√©clarations :
	v_nom [|CONSTANT] type [|NOT NULL] [|:= ...];
Autant que possible, r√©cup√©rer le type d'une colonne via <colonne>%TYPE;
ex: 
	v_country_name pays.libelle%TYPE;
	v_film_name    film.titre%TYPE;
	v_message      varchar2(256);
	

‚Ä¢ exceptions :
	BEGIN
		...
		...
	EXCEPTION
		WHEN NO_DATA_FOUND THEN ...
		WHEN ... THEN
			NULL;				-- √©quivalent d'un bloc de code vide
		WHEN OTHERS THEN ...
	END;

‚Ä¢ L'instruction ¬´NULL¬ª indique un bloc de code vide.
	

‚Ä¢ IF/THEN/ELSIF/ELSE/END IF :
	IF ...
	THEN
		...
	ELSIF ...
		...
	ELSE
		...
	END IF;

‚Ä¢ CASE : plusieurs syntaxes possibles ...
	CASE var 
		WHEN val THEN ...
		WHEN val THEN ...
	END CASE;

‚Ä¢ boucles :
	LOOP ... [|EXIT WHEN ...] ... END LOOP;
	
	WHILE ... LOOP ... END LOOP;
	
	FOR	v IN ... LOOP ... END LOOP;



‚óè CURSEUR :
Permet de parcourir une liste de r√©sultats.
‚Ä¢ curseur implicite :
D√©coule d'un ¬´ SELECT INTO ¬ª
	SELECT r1, r2, ... INTO v1, v2, ...
	
‚Ä¢ curseur explicite :
Curseur d√©clar√© :
	CURSOR <nom>[|(<param√®tres>)
	<TODO: SQL%ROWCOUNT>

‚Ä¢ utilisation d'un curseur :
	DECLARE 
		CURSOR <nom> IS <requ√™te>;
		...
	BEGIN
		OPEN <nom>;
		LOOP
			FETCH <nom> into ...; 
			EXIT WHEN <nom>%NOTFOUND;
			...
		END LOOP;
		CLOSE <nom>;
		...


‚óè PRAGMA_AUTONOMOUS_TRANSACTION :
Directive indiquant si chaque bloc doit √™tre autonome vis-√†-vis du commit de
 ses transactions & de la gestion des exceptions.



‚óè EX√âCUTER UNE INSTRUCTION DDL DANS DU PL/SQL :
Il faut enrober l'instruction dans un ¬´ EXECUTE IMMEDIATE ¬ª, SANS point-virgule,
qui prend en param√®tre UNE instruction sous forme de cha√Æne :

	EXECUTE IMMEDIATE 'DROP TABLE BLA_BLA_TABLE';

ou, avec l'op√©rateur de commentaire alternatif q'' :
	EXECUTE IMMEDIATE  q'[
          COMMENT ON TABLE JOBS IS 'Table stockant les param√®tres d'instances.']';


‚óè TYPES :
Dans un ent√™te de package ou un bloc DECLARE :
	TYPE ... IS [RECORD|OBJECT|VARRAY|TABLE|...]

‚Ä¢ RECORD( ... ) : pas de r√©cursivit√©, pas de stockage en base

‚Ä¢ OBJECT : D√âCONSEILL√â, stockable en base

‚Ä¢ COLLECTION: <TODO>

‚Ä¢ VARRAY :
tableau de taille fixe.
    DECLARE
        TYPE t_type IS VARRAY(ùëõ) OF <type>;
        v_var t_type

‚Ä¢ TABLE :
tableau de taille variable.
    DECLARE
        TYPE t_type IS TABLE OF <type>;
        v_var t_type;
    

‚Ä¢ parcourt d'une collection :
    FOR i IN <collection>.count LOOP
        ... <collection>(i) ...
    END LOOP;


‚óè variables :
Pas de variables globales.



‚óè proc√©dure ou fonction :
_ proc√©dures et fonctions POLYMORPHES.
_ ne pas mettre les parenth√®ses quand il n'y a pas de param√®tres
_ toujours mettre un ¬´/¬ª apr√®s la d√©claration d'une proc√©dure ou fonction


	[|CREATE [|OR REPLACE]] PROCEDURE <nom>[|(<params>)] IS
	BEGIN
		...
	END [|<nom>] /
	
	[|CREATE [|OR REPLACE]] FUNCTION <nom>[|(<params>)]
	RETURN <typeDeRetour>
	IS
	BEGIN
		...
	END [|<nom>] /
	

‚Ä¢ ex√©cuter une proc√©dure :
	execute <nomProc>;


‚Ä¢ qualificateurs de param√®tres :
_ IN

_ OUT,
_ IN OUT : passage PAR VALEUR.
La valeur du param√®tre original est recopi√©e dans un tampon, lui-m√™me pass√© en
 param√®tre √† la proc√©dure ;
Si la proc√©dure s'ach√®ve correctement, le tampon est recopi√© dans la variable originale.

_ NOCOPY : ¬´ OUT NOCOPY ¬ª, ¬´ IN OUT NOCOPY ¬ª : passage PAR R√âF√âRENCE.
C'est un HINT ! Conditions √† remplir ...
Les modifications ont lieu directement dans la variable d'origine.


‚Ä¢ ATTENTION ‚Äì ¬´ PROC√âDURE ANONYME ¬ª == proc√©dur√©e NOMM√âE mais d√©clar√©e dans une
autre proc√©dure, donc inaccessible de l'ext√©rieur.
Le concept de ¬´proc√©dure anonyme ¬ª en PL/SQL est tr√®s diff√©rent de ceux
 d'autres languages ! 

‚Ä¢ proc√©dure anonyme :
proc√©dure d√©marrant directement par un ¬´BEGIN¬ª, directement ex√©cut√©e, pas stock√©e :

‚Ä¢ proc√©dure nomm√©e == proc√©dure stock√©e :
Hors package :

	CREATE OR REPLACE PROCEDURE [|sch√©ma.]nomProc√©dure [|(params...)] IS
	BEGIN
		...
	END;
		
	CREATE OR REPLACE FUNCTION [|sch√©ma.]nomFonction [|(params...)]
		RETURN number IS
	(...)



‚óè FONCTIONS DE SORTIE :
	SET SERVEROUTPUT ON;
	...
	DBMS_OUTPUT.PUT_LINE();
	DBMS_OUTPUT.PUT_LINE();
	DBMS_OUTPUT.PUT_LINE();



‚óè exceptions :
‚Ä¢ capture :
	BEGIN
		...
	EXCEPTION
		#pas d'instructions avant les WHEN
		WHEN no_data_found THEN
			...
		# ¬´ others ¬ª : capture de toutes exceptions non g√©r√©es
		WHEN others THEN
			#utiliser SQLCODE, SLQERRM, ...
			IF SQLCODE = ... THEN ... END IF;
			...
	END;

‚Ä¢ fonctions utilisables dans les blocs EXCEPTION/WHEN :
_SQLCODE
_SQLERRM, SQLERRM(<sqlcode>) : message d'erreur de l'exception
_RAISE :	
_ RAISE <exception> :


‚Ä¢ d√©claration : dans bloc DECLARE :
	DECLARE
		ex1	EXCEPTION;
	BEGIN
		IF ... THEN RAISE ex1;


2 propri√©t√©s importantes :
_ libell√© de l'exception, le plus souvent renseign√©
_ SQLCODE, toujours renseign√©

‚Ä¢ r√©cup√©rer les informations d'un exception :
_SQLCODE
_ SQLERRM : message d'erreur 
	...
	EXCEPTION
		WHEN ... THEN
			DBMS_OUTPUT.PUT_LINE();
	END

‚Ä¢lever une exception :
	RAISE <nomException>
	
‚Ä¢lever une exception personnalis√©e :
Utile pour un gros projet avec une biblioth√®que d'exceptions.
	RAISE_APPLICATION_ERROR(errNum, mssg, bool);



‚óè EXEMPLE DE PROC√âDURE :

‚Ä¢ UNE PROC√âDURE STOCK√âE :
    PROCEDURE UPDATE_AND_LOG_CURVE_STATUS(
      p_id_message_tdb IN DIAPASON.DIA_TABLEAU_BORD.TABLEAU_BORD_ID%TYPE,
      p_type_courbe IN DIA_COURBES.TYPE_COURBE%TYPE,
      p_debut_periode IN DATE,
      p_fin_periode IN DATE,
      p_id_contrat IN DIA_CONTRATS.CONTRAT_ID%TYPE,
      p_format_message IN VARCHAR2)
    IS
    BEGIN
      DECLARE
        TYPE t_infos_courbe IS RECORD(
          ID_CONTRAT  DIA_COURBES.PARENT_ID%TYPE,
          DATE_COURBE DIA_COURBES.DATE_COURBE%TYPE,
          VERSION     DIA_COURBES.VERSION_COURBE%TYPE
        );

        TYPE t_liste_resultats IS TABLE OF t_infos_courbe;
        v_result t_liste_resultats;

        -- message de d√©tail √† ins√©rer dans le tableau de bord pour chaque courbe
        v_chaine_details VARCHAR2(255);

        v_id_detail DIA_TABLEAU_BORD_DETAILS.DETAILS_ID%TYPE;

      BEGIN
        -- mise √† jour des courbes de derni√®re version non obsol√®tes de type donn√©,
        --  d√©pendant d'un des contrats dont sont fournis les id,
        --  durant la p√©riode donn√©e
        UPDATE DIA_COURBES
        SET
          PUBLIABLE = 1
        WHERE
          TYPE_COURBE = p_type_courbe
          AND EST_DERNIERE_VERSION = 1
          AND PUBLIABLE = 0
          AND DATE_COURBE BETWEEN p_debut_periode AND p_fin_periode
          AND PARENT_ID = p_id_contrat
        RETURNING
          PARENT_ID, DATE_COURBE, VERSION_COURBE BULK COLLECT INTO v_result;

        IF (0 = v_result.COUNT)
        THEN
          PKGDIA.TdbCreerDetails(p_id_message_tdb, SYSDATE, p_message_sans_modif, 1, NULL, v_id_detail);
        END IF;

        -- insertion d'un d√©tail de message en tableau de bord pour chaque courbe mise √† jour
        FOR i IN 1..v_result.COUNT
        LOOP
          v_chaine_details := replace(p_format_message, '{0}', PKGDIA.NomCourbe(
              PKGDIA.c_C17E, v_result(i).DATE_COURBE, v_result(i).ID_CONTRAT, v_result(i).VERSION, SYSDATE));

          PKGDIA.TdbCreerDetails(p_id_message_tdb, SYSDATE, v_chaine_details, 1, NULL, v_id_detail);
        END LOOP ;

      END;
    END;

‚Ä¢ UNE FONCTION ANONYME :
-- pour sqlplus ou sqlDeveloper : 
set serveroutput on;

BEGIN
    DECLARE
        -- r√©cup√®re la liste de toutes les paires EDA/EDE utilis√©es par les liens
        CURSOR pairList IS
            SELECT DISTINCT lbd.bae_id, lbd.dre_id 
            FROM link_bae_dre lbd
            ORDER BY lbd.bae_id, lbd.dre_id ;

        pair_bae_id number(19,0);
        pair_dre_id number(19,0);

        lastLbdId number(19,0);
        lastEndDate date;

    BEGIN
        open pairList;
        -- boucle √† travers la liste de paires EDA/EDE
        loop
            fetch pairList into pair_bae_id, pair_dre_id;
            EXIT WHEN pairList%NOTFOUND;
            
            -- infos : affiche chaque paire EDA/EDE trait√©e
            dbms_output.put_line( chr(10) || '‚óè paire ' || pair_bae_id || '/' || pair_dre_id || ' : ');

            -- ID et date de fin du dernier lien trait√© dans la boucle ci-dessous
            -- (ordonn√©s par dates croissantes de d√©but et de fin)
            lastLbdId := NULL;
            lastEndDate := NULL;

            -- boucle √† travers les liens relatifs √† une m√™me paire EDE/EDA,
            -- ordonn√©s par date croissante
            for line in (
                select * from link_bae_dre lbd
                    where lbd.dre_id = pair_dre_id and lbd.bae_id = pair_bae_id
                    order by lbd.lbd_start_date, lbd.lbd_end_date,lbd.lbd_id
            )
            loop
                -- infos : lien trait√©
                dbms_output.put_line(
                    'lbd_id = ' || line.lbd_id ||
                    ', lbd_bae_id = ' || line.bae_id ||
                    ', lbd_dre_id = ' || line.dre_id ||
                    ', lbd_start_date = ' || line.lbd_start_date ||
                    ', lbd_end_date = ' || line.lbd_end_date
                );
                
                if (lastLbdId is not null)
                then
                    -- cl√¥t le lien pr√©c√©demment examin√© s'il est encore ouvert
                    -- √† la date de d√©but du lien en cours, en armant sa date de
                    -- fin au jours pr√©c√©dant la date de d√©part du lien en cours
                    if line.lbd_start_date <= lastEndDate
                    then
                        -- infos : requ√™te ex√©cut√©e
                        dbms_output.put_line(
                            '    ‚Ä¢ requ√™te ex√©cut√©e : ' ||
                            'update link_bae_dre set lbd_end_date = ' ||
                            (line.lbd_start_date - interval '1' day) ||
                            ' where lbd_id = ' || lastLbdId
                        );
                        update link_bae_dre set lbd_end_date = (line.lbd_start_date - interval '1' day) where lbd_id = lastLbdId;
                    end if;
                end if;
               
               lastLbdId := line.lbd_id;
               lastEndDate := line.lbd_end_date;
            end loop;

        end loop;
    END;
    -- ins√©rer COMMIT ici si le script est satisfaisant
    -- COMMIT;
END;
/

