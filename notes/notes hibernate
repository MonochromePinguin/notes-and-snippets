â— objets notables :
â€¢ SessionFactory :
	abstraction de la BdD
â€¢ Session :
	abstraction de la connexion Ã  la BdD
â€¢ Transation :
	session.beginTransaction()

â€¢ TransactionFactory :
	optionnel.
â€¢

â€¢ JTA Â« Java Transaction API Â» :
protocole de commit Ã  2 phases, trÃ¨s efficace pour transactions courtes,
mais lourd pour grosses transactions.
â†’ 2 commits Ã  rÃ©aliser :
_ le 1er verrouille la table,
_ le 2e commit le tout.


â— CLASSES PERSISTANTES :
_ classes sauvÃ©es en BdD.
â€¢ bonnes pratiques :
_ classes POJO (Â« Plain Old Java Object Â») :
simples classes,
	_ avec constructeur par dÃ©faut (Â« sans paramÃ¨tres Â»),
	_ propriÃ©tÃ©s persistÃ©es privÃ©es avec getters/setters


â— JPA :
Â« Java Persistance API Â», sur laquelle  Hibernate est basÃ©e.
â€¢ par convention, informations sur la couche de persistance stockÃ©es dans
    META-INF/persistence.xml

â€¢ dÃ©marche par dÃ©faut :
	EntityManagerFactory emf = createEntityManagerFactory("nomTable");
	EntityManager em = emf.createEntityManager();
	EntityTransaction tx = em.getTransaction();
	tx.begin();
	em.persist(objetÃ€persister);
	tx.commit();
  
â€¢ mÃ©thodes liÃ©es aux objets persistants :
	new()
	.refresh() (utile en cas d'accÃ¨s concurents)
	.remove()   â†’ retire l'objet du la gestion par le JPA ET de la BdD
	.persist()  

    
â— ANNOTATIONS JPA :
â€¢ classes :
	@Entity     â†’   persistance
	@Table(name = "table", schema = "BdD" [, catalog = ""] )
â€¢ colonnes :
	@Id
	@Generatedalue
	
	@Column(name = "col")
	@Column(name="colonne", unique = true, nullable = false)
    @Column(length = ğ‘›)

â— config XML :
<class name="FQCN" table="TABLE">
	<id name="id" type="java.lang.Long">
		<column name="REVS_ID" />
		<generator class="sequence">
			<param name="sequence">SEQ_REVS_ID</param>
		</generator>
	</id>

	<property name="date" type="java.util.Date">
		<column name="REVS_DATE" />
	</property>

	<set name="realizedErasedSimultaneousVolumeValues" cascade="all" order-by="REVSV_ID">
		<key column="REVS_ID" not-null="true" />
		<one-to-many
			class="com.bla.RealizedErasedSimultaneousVolumeValue" />
	</set>

	<one-to-one name="calculationProgress"
		class="com.rte.crema.dao.calculationprogress.entity.CalculationProgress"
		foreign-key="CAL_ID"
		constrained="true"		#s'assure que l'entitÃ© cible existe 
		cascade="save-update"
		lazy="false" fetch="select" />


</class>


â— HQL :
    Query query = session.createQuery("FROM table");
    List<Obj> list = query.list();



â— diffÃ©rences d'implÃ©mentation entre couches JPA et Hibernate :
â€¢ standard JPA :
    TransactionManager â†’ EntityManager â†’ PersistenceUnit â†’ DataSource
â€¢ Hibernate :                   |       /
    TransactionManager â†’     SessionManager â†’ DataSource 


â— hibernate.cfg.xml :
	Doit faire le lien avec les classes utilisÃ©es via des entrÃ©es Â«mappingÂ»
	
â€¢ DÃ‰BOGUAGE - afficher les requÃªtes SQL exÃ©cutÃ©es par hibernate :

<hibernate-configuration>
	<session-factory>
		...
		<!-- Echo all executed SQL to stdout -->
		<property name="show_sql">false</property>
		<property name="format_sql">false</property>
		...
		
